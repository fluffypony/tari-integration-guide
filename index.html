<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Tari Exchange Integration Guide</title>
    <style>
        /* Light mode (default) */
        :root {
            --bg-primary: #f8f9fa;
            --bg-secondary: white;
            --bg-tertiary: #f8f9fa;
            --text-primary: #333;
            --text-secondary: #34495e;
            --text-tertiary: #2c3e50;
            --border-color: #dee2e6;
            --accent-color: #3498db;
            --success-bg: #d4edda;
            --success-border: #c3e6cb;
            --success-accent: #28a745;
            --warning-bg: #fff3cd;
            --warning-border: #ffeaa7;
            --warning-accent: #f39c12;
            --info-bg: #d1ecf1;
            --info-border: #bee5eb;
            --info-accent: #17a2b8;
            --code-bg: #f8f9fa;
            --code-terminal-bg: #2d3748;
            --code-terminal-text: #e2e8f0;
            --tab-inactive: #6c757d;
            --pseudocode-bg: #f8f9fa;
            --pseudocode-border: #6c757d;
            --grpcurl-bg: #e8f5e8;
            --grpcurl-border: #28a745;
        }
        
        
        /* Network badge base styles */
        .network-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
            margin-right: 5px;
        }
        
        .mainnet { 
            background: #4caf50; 
            color: white; 
        }
        
        .testnet { 
            background: #ff9800; 
            color: black; 
        }
        
        .nextnet { 
            background: #29b6f6; 
            color: white; 
        }        /* Dark mode */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #1a1a1a;
                --bg-secondary: #2d2d2d;
                --bg-tertiary: #3d3d3d;
                --text-primary: #e0e0e0;
                --text-secondary: #b0b0b0;
                --text-tertiary: #ffffff;
                --border-color: #404040;
                --accent-color: #4db8ff;
                --success-bg: #1a3d2e;
                --success-border: #2d5a45;
                --success-accent: #4caf50;
                --warning-bg: #3d2f1a;
                --warning-border: #5a4529;
                --warning-accent: #ff9800;
                --info-bg: #1a2d3d;
                --info-border: #2d455a;
                --info-accent: #29b6f6;
                --code-bg: #3d3d3d;
                --code-terminal-bg: #1e1e1e;
                --code-terminal-text: #f0f0f0;
                --tab-inactive: #888;
                --pseudocode-bg: #2a2a2a;
                --pseudocode-border: #555;
                --grpcurl-bg: #1a3d2a;
                --grpcurl-border: #4caf50;
            }
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: var(--bg-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .container {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease;
        }
        
        h1 {
            color: var(--text-tertiary);
            border-bottom: 3px solid var(--accent-color);
            padding-bottom: 10px;
        }
        
        h2 {
            color: var(--text-secondary);
            margin-top: 40px;
            padding: 15px 0;
            border-left: 4px solid var(--accent-color);
            padding-left: 20px;
        }
        
        h3 {
            color: var(--text-tertiary);
            margin-top: 30px;
        }
        
        .warning {
            background: var(--warning-bg);
            border: 1px solid var(--warning-border);
            border-left: 4px solid var(--warning-accent);
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }
        
        .info {
            background: var(--info-bg);
            border: 1px solid var(--info-border);
            border-left: 4px solid var(--info-accent);
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }
        
        .success {
            background: var(--success-bg);
            border: 1px solid var(--success-border);
            border-left: 4px solid var(--success-accent);
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }
        
        code {
            background: var(--code-bg);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', monospace;
            color: var(--text-primary);
            transition: background-color 0.3s ease;
        }
        
        pre {
            background: var(--code-terminal-bg);
            color: var(--code-terminal-text);
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 20px 0;
            transition: background-color 0.3s ease;
        }
        
        .tab-buttons {
            display: flex;
            background: var(--bg-tertiary);
            border-radius: 6px 6px 0 0;
            border: 1px solid var(--border-color);
            border-bottom: none;
            flex-wrap: wrap;
            transition: background-color 0.3s ease;
        }
        
        .tab-button {
            padding: 10px 15px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: var(--tab-inactive);
            font-size: 14px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .tab-button.active {
            background: var(--code-terminal-bg);
            color: var(--code-terminal-text);
        }
        
        .tab-button:hover {
            background: var(--border-color);
            color: var(--text-primary);
        }
        
        .tab-content {
            display: none;
            background: var(--code-terminal-bg);
            color: var(--code-terminal-text);
            padding: 20px;
            border-radius: 0 0 6px 6px;
            overflow-x: auto;
            transition: background-color 0.3s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .step-number {
            background: var(--accent-color);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
        }
        
        .toc {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
            transition: background-color 0.3s ease;
        }
        
        .toc a {
            color: var(--accent-color);
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .toc a:hover {
            text-decoration: underline;
        }
        
        .checklist {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
            transition: background-color 0.3s ease;
        }
        
        .architecture-diagram {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            transition: background-color 0.3s ease;
        }
        
        .flow-box {
            display: inline-block;
            background: var(--info-bg);
            border: 2px solid var(--info-accent);
            border-radius: 6px;
            padding: 15px;
            margin: 10px;
            min-width: 120px;
            color: var(--text-primary);
            transition: background-color 0.3s ease;
        }
        
        .arrow {
            font-size: 24px;
            color: var(--info-accent);
            margin: 0 10px;
        }
        
        .pseudocode-box {
            background: var(--pseudocode-bg);
            border: 2px solid var(--pseudocode-border);
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            transition: background-color 0.3s ease;
        }
        
        .pseudocode-box h4 {
            color: var(--text-tertiary);
            margin-top: 0;
        }
        
        .grpcurl-box {
            background: var(--grpcurl-bg);
            border: 2px solid var(--grpcurl-border);
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            transition: background-color 0.3s ease;
        }
        
        .grpcurl-box h4 {
            color: var(--text-tertiary);
            margin-top: 0;
        }
        
        /* Dark mode specific adjustments */
        @media (prefers-color-scheme: dark) {
            .container {
                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            }
            
            /* Ensure network badges are readable in dark mode */
            .mainnet { 
                background: #4caf50; 
                color: white; 
            }
            
            .testnet { 
                background: #ff9800; 
                color: black; 
            }
            
            .nextnet { 
                background: #29b6f6; 
                color: white; 
            }
            
            /* Adjust link colors for better dark mode visibility */
            a {
                color: var(--accent-color);
            }
            
            a:visited {
                color: #bb86fc;
            }
        }
        
        /* Smooth transitions for theme changes */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        
        /* Ensure form elements work well in dark mode */
        @media (prefers-color-scheme: dark) {
            input[type="checkbox"] {
                filter: invert(1) hue-rotate(180deg);
            }
            
            /* Ensure code syntax highlighting is readable */
            pre code {
                color: var(--code-terminal-text);
            }
            
            /* Improve scrollbar appearance in dark mode */
            ::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }
            
            ::-webkit-scrollbar-track {
                background: var(--bg-tertiary);
            }
            
            ::-webkit-scrollbar-thumb {
                background: var(--border-color);
                border-radius: 4px;
            }
            
            ::-webkit-scrollbar-thumb:hover {
                background: var(--accent-color);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🏦 Complete Tari Exchange Integration Guide</h1>
        
        <div class="info">
            <strong>📋 What You'll Learn:</strong> This comprehensive guide covers everything needed to integrate Minotari (XTM) into your cryptocurrency exchange, from node setup to transaction monitoring and fund management. Every example includes pseudocode for security understanding and grpcurl commands for testing.

        <div class="warning">
            <strong>⚠️ Security Warning:</strong> This guide contains placeholder credentials and URLs marked as "PLACEHOLDER" or "secure_password_here". Replace ALL placeholders with actual values and use secure credential management (environment variables, secrets managers) in production. Never use hardcoded credentials.
        </div>        </div>

        <div class="toc">
            <h3>📖 Table of Contents</h3>
            <ul>
                <li><a href="#overview">1. Overview & Architecture</a></li>
                <li><a href="#environment-setup">2. Development Environment Setup</a></li>
                <li><a href="#node-setup">3. Node Setup & Configuration</a></li>
                <li><a href="#wallet-creation">4. Wallet Creation & Management</a></li>
                <li><a href="#deposit-monitoring">5. Deposit Monitoring</a></li>
                <li><a href="#withdrawal-processing">6. Withdrawal Processing</a></li>
                <li><a href="#security-best-practices">7. Security Best Practices</a></li>
                <li><a href="#production-deployment">8. Production Deployment</a></li>
                <li><a href="#troubleshooting">9. Troubleshooting</a></li>
                <li><a href="#api-reference">10. Complete API Reference</a></li>
            </ul>
        </div>

        <h2 id="overview">🏗️ 1. Overview & Architecture</h2>
        
        <div class="architecture-diagram">
            <h3>Exchange Integration Architecture</h3>
            <div>
                <div class="flow-box">Exchange Frontend</div>
                <span class="arrow">→</span>
                <div class="flow-box">Exchange Backend</div>
                <span class="arrow">→</span>
                <div class="flow-box">Read-Only Wallet<br/>(Monitoring)</div>
            </div>
            <div style="margin: 20px 0;">
                <div class="flow-box">Cold Storage Wallet<br/>(Withdrawals)</div>
                <span class="arrow">↔</span>
                <div class="flow-box">Minotari Base Node</div>
                <span class="arrow">↔</span>
                <div class="flow-box">Tari Network</div>
            </div>
        </div>

        <h3>🎯 Integration Components</h3>
        <ul>
            <li><strong>Minotari Base Node:</strong> Syncs with the Tari network and provides blockchain data</li>
            <li><strong>Read-Only Wallet:</strong> Monitors incoming deposits without spending ability</li>
            <li><strong>Cold Storage Wallet:</strong> Secure wallet for processing withdrawals</li>
            <li><strong>gRPC Interface:</strong> API communication layer</li>
        </ul>

        <h3>🌐 Network Support</h3>
        <div>
            <span class="network-badge mainnet">Mainnet</span>
            <span class="network-badge testnet">Testnet</span>
            <span class="network-badge nextnet">Nextnet</span>
        </div>

        <h2 id="environment-setup">⚙️ 2. Development Environment Setup</h2>

        <div class="warning">
            <strong>⚠️ Prerequisites:</strong> Before starting, ensure you have administrative access to your deployment environment and understand basic cryptocurrency security principles.
        </div>

        <h3>🔧 System Requirements</h3>
        <ul>
            <li><strong>OS:</strong> Linux (Ubuntu 20.04+), macOS (10.15+), or Windows 10+</li>
            <li><strong>RAM:</strong> Minimum 4GB, Recommended 8GB+</li>
            <li><strong>Storage:</strong> 50GB+ SSD for blockchain data</li>
            <li><strong>Network:</strong> Stable internet connection</li>
        </ul>

        <h3>🛠️ Development Tools Setup</h3>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'nodejs-setup')">Node.js</button>
                <button class="tab-button" onclick="switchTab(event, 'python-setup')">Python</button>
                <button class="tab-button" onclick="switchTab(event, 'rust-setup')">Rust</button>
                <button class="tab-button" onclick="switchTab(event, 'php-setup')">PHP</button>
                <button class="tab-button" onclick="switchTab(event, 'grpcurl-setup')">grpcurl</button>
            </div>
            
            <div id="nodejs-setup" class="tab-content active">
                <pre><code># Install Node.js 18+ and npm
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs

# Install gRPC packages
npm install @grpc/grpc-js @grpc/proto-loader

# Install additional utilities
npm install axios lodash</code></pre>
            </div>
            
            <div id="python-setup" class="tab-content">
                <pre><code># Install Python 3.8+ and pip
sudo apt-get update
sudo apt-get install python3 python3-pip

# Install gRPC packages
pip3 install grpcio grpcio-tools protobuf

# Install additional utilities
pip3 install asyncio aiofiles pycryptodome</code></pre>
            </div>
            
            <div id="rust-setup" class="tab-content">
                <pre><code># Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env

# Install Tari from source (optional)
git clone https://github.com/tari-project/tari.git
cd tari
cargo build --release</code></pre>
            </div>
            
            <div id="php-setup" class="tab-content">
                <pre><code># Install PHP 8.0+ and Composer
sudo apt-get install php8.0 php8.0-cli php8.0-mbstring composer

# Install gRPC extension
sudo apt-get install php8.0-grpc

# Install Protobuf tools
composer require google/protobuf spiral/php-grpc</code></pre>
            </div>
            
            <div id="grpcurl-setup" class="tab-content">
                <pre><code># Install grpcurl (essential for testing)

# Linux
curl -L https://github.com/fullstorydev/grpcurl/releases/download/v1.8.7/grpcurl_1.8.7_linux_x86_64.tar.gz | tar -xz
sudo mv grpcurl /usr/local/bin/

# macOS
brew install grpcurl

# Windows (using chocolatey)
choco install grpcurl

# Test installation
grpcurl --version

# Test Tari connection (once services are running)
grpcurl -plaintext localhost:18142 list
grpcurl -plaintext localhost:18143 list</code></pre>
            </div>
        </div>

        <h3>📦 Install Tari Binaries</h3>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'install-linux')">Linux</button>
                <button class="tab-button" onclick="switchTab(event, 'install-macos')">macOS</button>
                <button class="tab-button" onclick="switchTab(event, 'install-windows')">Windows</button>
            </div>
            
            <div id="install-linux" class="tab-content active">
                <pre><code># Download latest release
curl -L # PLACEHOLDER: Replace with actual Tari Linux download URL
curl -L https://github.com/tari-project/tari/releases/latest/download/minotari-linux.tar.gz -o minotari.tar.gz

# Extract
tar -xzf minotari.tar.gz

# Move to system path
sudo mv minotari/* /usr/local/bin/

# Verify installation
minotari_node --version</code></pre>
            </div>
            
            <div id="install-macos" class="tab-content">
                <pre><code># Download latest release
curl -L # PLACEHOLDER: Replace with actual Tari macOS download URL
curl -L https://github.com/tari-project/tari/releases/latest/download/minotari-macos.dmg -o minotari.dmg

# Mount and install
hdiutil attach minotari.dmg
cp -R /Volumes/Minotari/minotari_* /usr/local/bin/

# Verify installation
minotari_node --version</code></pre>
            </div>
            
            <div id="install-windows" class="tab-content">
                <pre><code># Download from https://tari.com/downloads/
# Run the installer executable
# Or use PowerShell:

Invoke-WebRequest -Uri "# PLACEHOLDER: Replace with actual Tari Windows download URL
Invoke-WebRequest -Uri "https://github.com/tari-project/tari/releases/latest/download/minotari-windows.exe"" -OutFile "minotari-installer.exe"
.\minotari-installer.exe

# Verify installation
minotari_node.exe --version</code></pre>
            </div>
        </div>

        <h2 id="node-setup">🖥️ 3. Node Setup & Configuration</h2>

        <div class="info">
            <strong>📍 Step 1:</strong> Setting up your Minotari base node is the foundation of your exchange integration. This node will sync with the Tari network and provide blockchain data.
        </div>

        <h3>🚀 Initial Node Setup</h3>

        <div class="checklist">
            <h4>Pre-Setup Checklist:</h4>
            <label><input type="checkbox"> Server meets minimum requirements</label><br>
            <label><input type="checkbox"> Firewall configured for Tari ports (18141, 18142, 18143)</label><br>
            <label><input type="checkbox"> Tor installed (Linux/macOS) or IP configured</label><br>
            <label><input type="checkbox"> Backup strategy planned</label>
        </div>

        <h4><span class="step-number">1</span>Initialize the Node</h4>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'node-pseudocode')">Pseudocode</button>
                <button class="tab-button" onclick="switchTab(event, 'node-grpcurl')">grpcurl Test</button>
                <button class="tab-button" onclick="switchTab(event, 'node-init-command')">Command Line</button>
                <button class="tab-button" onclick="switchTab(event, 'node-init-script')">Automated Script</button>
            </div>
            
            <div id="node-pseudocode" class="tab-content active">
                <div class="pseudocode-box">
                    <h4>🧠 Node Setup Logic</h4>
                    <pre><code>FUNCTION setupTariNode():
    // Step 1: Check system requirements
    IF (disk_space < 50GB OR memory < 4GB):
        THROW "Insufficient system resources"
    
    // Step 2: Initialize node configuration
    IF (config_file_exists):
        LOAD existing_config
    ELSE:
        CREATE default_config
        SET network = "mainnet" // or "testnet" for testing
        SET grpc_enabled = true
        SET grpc_port = 18142
        SET p2p_port = 18141
    
    // Step 3: Generate node identity
    IF (NOT node_identity_exists):
        GENERATE new_keypair
        SAVE keypair_to_secure_location
        LOG "Node identity created: " + public_key
    
    // Step 4: Configure network transport
    IF (tor_available):
        SET transport = "tor"
    ELSE:
        SET transport = "tcp"
        CONFIGURE public_ip_address
    
    // Step 5: Start synchronization
    START node_process
    WAIT_FOR initial_sync
    
    RETURN node_status</code></pre>
                </div>
            </div>
            
            <div id="node-grpcurl" class="tab-content">
                <div class="grpcurl-box">
                    <h4>🧪 Test Node with grpcurl</h4>
                    <pre><code># Test if node is running and accessible
grpcurl -plaintext localhost:18142 list

# Expected output:
# grpc.reflection.v1alpha.ServerReflection
# tari.rpc.BaseNode

# Get node version
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetVersion

# Get node identity (public key and addresses)
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/Identify

# Check sync status
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetTipInfo

# Check network connectivity
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetNetworkStatus

# List connected peers
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/ListConnectedPeers

# Note: The following scripts require 'jq' for JSON parsing
# Install with: brew install jq (macOS) or apt-get install jq (Ubuntu)
# Quick health check script
#!/bin/bash
echo "=== Node Health Check ==="
echo "1. Testing gRPC connectivity..."
if grpcurl -plaintext -connect-timeout 5 localhost:18142 list > /dev/null 2>&1; then
    echo "✅ gRPC accessible"
    
    echo "2. Getting tip info..."
    grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetTipInfo
    
    echo "3. Checking network status..."
    grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetNetworkStatus
else
    echo "❌ gRPC not accessible - check if node is running"
fi</code></pre>
                </div>
            </div>
            
            <div id="node-init-command" class="tab-content">
                <pre><code># Start the node for first-time setup
minotari_node

# When prompted:
# - Create node identity: y
# - Mine: n (for exchange use)
# - Network: mainnet (or testnet for testing)</code></pre>
            </div>
            
            <div id="node-init-script" class="tab-content">
                <pre><code>#!/bin/bash
# automated-node-setup.sh

# Create Tari directory
mkdir -p ~/.tari/mainnet/config

# Generate basic config
cat > ~/.tari/mainnet/config/config.toml << 'EOF'
[base_node.mainnet]
grpc_enabled = true
grpc_base_node_address = "127.0.0.1:18142"
transport = "tor"
allow_test_addresses = false

[wallet]
grpc_enabled = true
grpc_address = "127.0.0.1:18143"
EOF

# Start node
minotari_node --init</code></pre>
            </div>
        </div>

<h2 id="wallet-creation">💼 4. Wallet Creation & Management</h2>

        <div class="info">
            <strong>💡 Concept:</strong> Your exchange needs two types of wallets: a read-only monitoring wallet for tracking deposits, and a secure cold storage wallet for processing withdrawals.
        </div>

        <h3>🔐 Wallet Architecture</h3>

        <div class="architecture-diagram">
            <div>
                <div class="flow-box">Hot Wallet<br/>(Monitoring Only)</div>
                <span class="arrow">→</span>
                <div class="flow-box">Database<br/>Updates</div>
                <span class="arrow">→</span>
                <div class="flow-box">User Balance<br/>Credits</div>
            </div>
            <div style="margin: 20px 0;">
                <div class="flow-box">Cold Wallet<br/>(Withdrawals)</div>
                <span class="arrow">→</span>
                <div class="flow-box">Air-Gapped<br/>Security</div>
                <span class="arrow">→</span>
                <div class="flow-box">Manual<br/>Approval</div>
            </div>
        </div>

        <h4><span class="step-number">1</span>Create Monitoring Wallet</h4>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'wallet-pseudocode')">Pseudocode</button>
                <button class="tab-button" onclick="switchTab(event, 'wallet-grpcurl')">grpcurl Test</button>
                <button class="tab-button" onclick="switchTab(event, 'wallet-setup')">Setup Commands</button>
            </div>
            
            <div id="wallet-pseudocode" class="tab-content active">
                <div class="pseudocode-box">
                    <h4>🧠 Wallet Creation Logic</h4>
                    <pre><code>FUNCTION createMonitoringWallet():
    // Step 1: Initialize wallet with secure passphrase
    passphrase = generateSecurePassphrase(256) // 256-bit entropy
    
    // Step 2: Create wallet identity
    TRY:
        walletIdentity = tariWallet.createIdentity(passphrase)
        
        // Step 3: Configure for monitoring only
        walletConfig = {
            name: "exchange-monitoring",
            grpc_enabled: true,
            grpc_address: "127.0.0.1:18143",
            grpc_authentication: {
                username: "exchange_monitor",
                password: generateSecurePassword()
            },
            base_node_service_peers: [trusted_node_address],
            network: "mainnet", // or "testnet"
            spending_key_access: false // Read-only
        }
        
        // Step 4: Generate deposit address
        depositAddress = walletIdentity.getOneSidedAddress()
        
        // Step 5: Store securely
        secureStorage.store({
            wallet_id: walletIdentity.public_key,
            deposit_address: depositAddress,
            grpc_credentials: walletConfig.grpc_authentication,
            created_at: getCurrentTimestamp()
        })
        
        // Step 6: Start monitoring service
        startWalletSync()
        
        RETURN {
            address: depositAddress,
            wallet_id: walletIdentity.public_key,
            status: "ready_for_deposits"
        }
        
    CATCH (error):
        LOG "Wallet creation failed: " + error.message
        THROW "Failed to create monitoring wallet"</code></pre>
                </div>
            </div>
            
            <div id="wallet-grpcurl" class="tab-content">
                <div class="grpcurl-box">
                    <h4>🧪 Test Wallet with grpcurl</h4>
                    <pre><code># Check if wallet is running and accessible
grpcurl -plaintext localhost:18143 list

# Get wallet identity and addresses
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/Identify

# Get complete address information
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetCompleteAddress

# Check wallet synchronization status
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetState

# Test wallet connectivity to base node
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetNetworkStatus

# Wallet health check script
#!/bin/bash
echo "=== Wallet Health Check ==="

echo "1. Testing wallet accessibility..."
if grpcurl -plaintext -connect-timeout 5 localhost:18143 list > /dev/null 2>&1; then
    echo "✅ Wallet gRPC accessible"
else
    echo "❌ Wallet not accessible"
    exit 1
fi

echo "2. Getting wallet identity..."
IDENTITY=$(grpcurl -plaintext localhost:18143 tari.rpc.Wallet/Identify 2>/dev/null)
if [ $? -eq 0 ]; then
    PUBLIC_KEY=$(echo "$IDENTITY" | jq -r '.public_key')
    echo "Wallet Public Key: ${PUBLIC_KEY:0:16}..."
else
    echo "❌ Could not get wallet identity"
fi

echo "3. Checking sync status..."
STATE=$(grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetState 2>/dev/null)
if [ $? -eq 0 ]; then
    SCANNED_HEIGHT=$(echo "$STATE" | jq -r '.scanned_height // 0')
    BALANCE=$(echo "$STATE" | jq -r '.balance.available_balance // 0')
    
    echo "Scanned Height: $SCANNED_HEIGHT"
    echo "Available Balance: $BALANCE microXTM"
else
    echo "❌ Could not get wallet state"
fi

echo "4. Network connectivity..."
NETWORK=$(grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetNetworkStatus 2>/dev/null)
if [ $? -eq 0 ]; then
    STATUS=$(echo "$NETWORK" | jq -r '.status // "Unknown"')
    CONNECTIONS=$(echo "$NETWORK" | jq -r '.num_node_connections // 0')
    
    echo "Network Status: $STATUS"
    echo "Node Connections: $CONNECTIONS"
else
    echo "❌ Could not get network status"
fi</code></pre>
                </div>
            </div>
            
            <div id="wallet-setup" class="tab-content">
                <pre><code># Initialize wallet for first time
minotari_console_wallet --init

# When prompted, choose:
# - Create new wallet: y
# - Set password: [secure password]
# - Recover from seed: n (unless restoring)
# - Network: mainnet

# Start wallet with gRPC enabled
minotari_console_wallet --enable-grpc

# In separate terminal, verify wallet is accessible
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetCompleteAddress</code></pre>
            </div>
        </div>

        <h4><span class="step-number">2</span>Cold Storage Wallet Setup</h4>

        <div class="warning">
            <strong>🔒 Security Critical:</strong> The cold storage wallet should be on an air-gapped system or secure hardware wallet for maximum security.
        </div>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'cold-pseudocode')">Pseudocode</button>
                <button class="tab-button" onclick="switchTab(event, 'cold-setup')">Setup Process</button>
                <button class="tab-button" onclick="switchTab(event, 'cold-security')">Security Measures</button>
            </div>
            
            <div id="cold-pseudocode" class="tab-content active">
                <div class="pseudocode-box">
                    <h4>🧠 Cold Storage Setup Logic</h4>
                    <pre><code>FUNCTION setupColdStorageWallet():
    // Step 1: Air-gapped environment validation
    IF (networkConnected() OR usbDevicesConnected()):
        THROW "Environment not sufficiently isolated"
    
    // Step 2: Generate seed phrase securely
    seedPhrase = generateMnemonic(24) // 24-word BIP39 mnemonic
    validateMnemonic(seedPhrase)
    
    // Step 3: Create physical backup
    printSeedPhrase(seedPhrase) // On paper, never digital
    createMetalBackup(seedPhrase) // Fire/water resistant
    
    // Step 4: Initialize wallet from seed
    coldWallet = createWalletFromSeed(seedPhrase)
    
    // Step 5: Generate multiple addresses for rotation
    addresses = []
    FOR i = 0 TO 9:
        address = coldWallet.deriveAddress(i)
        addresses.append(address)
    
    // Step 6: Export public keys only for monitoring
    publicKeys = []
    FOR EACH address IN addresses:
        publicKeys.append(address.getPublicKey())
    
    // Step 7: Secure the seed
    securelyDestroySeedFromMemory()
    storeInSecureSafe(seedPhrasePaper)
    
    // Step 8: Create watch-only wallet for hot system
    watchOnlyWallet = createWatchOnlyWallet(publicKeys)
    
    RETURN {
        watch_only_keys: publicKeys,
        addresses: addresses,
        backup_completed: true
    }</code></pre>
                </div>
            </div>
            
            <div id="cold-setup" class="tab-content">
                <pre><code># Cold storage setup on air-gapped machine

# 1. Disconnect from all networks
sudo systemctl stop networking
sudo systemctl disable networking

# 2. Remove WiFi/Bluetooth capability
sudo rfkill block all

# 3. Create cold wallet
minotari_console_wallet --create-id --seed-words

# 4. Backup seed phrase (write on paper)
# Store in multiple secure locations

# 5. Export public key for monitoring
minotari_console_wallet --export-spent-outputs > cold_wallet_outputs.json

# 6. Transfer public key data to hot system via secure method
# (QR code, encrypted USB, etc.)</code></pre>
            </div>
            
            <div id="cold-security" class="tab-content">
                <pre><code># Security measures for cold storage

## Physical Security
- [ ] Dedicated air-gapped machine
- [ ] No network interfaces
- [ ] Secure facility storage
- [ ] Access logging

## Seed Phrase Security
- [ ] 24-word BIP39 mnemonic
- [ ] Multiple physical copies
- [ ] Fireproof/waterproof storage
- [ ] Geographic distribution

## Operational Security
- [ ] Multi-person approval process
- [ ] Hardware security modules (HSM)
- [ ] Transaction signing ceremony
- [ ] Audit trail logging

## Emergency Procedures
- [ ] Seed phrase recovery process
- [ ] Emergency contact procedures
- [ ] Insurance coverage
- [ ] Legal documentation</code></pre>
            </div>
        </div>

        <h2 id="deposit-monitoring">📥 5. Deposit Monitoring</h2>

        <div class="info">
            <strong>💡 Concept:</strong> Users send funds to your exchange's one-sided address with a payment ID. Your system monitors for these transactions and credits user accounts.
        </div>

        <h3>🔄 Deposit Flow</h3>

        <div class="architecture-diagram">
            <div>
                <div class="flow-box">User Initiates<br/>Deposit</div>
                <span class="arrow">→</span>
                <div class="flow-box">Exchange Generates<br/>Payment ID</div>
                <span class="arrow">→</span>
                <div class="flow-box">User Sends XTM<br/>with Payment ID</div>
            </div>
            <div style="margin: 20px 0;">
                <div class="flow-box">Transaction<br/>Confirmed</div>
                <span class="arrow">←</span>
                <div class="flow-box">Exchange Credits<br/>User Account</div>
                <span class="arrow">←</span>
                <div class="flow-box">System Detects<br/>Transaction</div>
            </div>
        </div>

        <h4><span class="step-number">1</span>Generate Deposit Address</h4>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'deposit-pseudocode')">Pseudocode</button>
                <button class="tab-button" onclick="switchTab(event, 'deposit-grpcurl')">grpcurl</button>
                <button class="tab-button" onclick="switchTab(event, 'deposit-nodejs')">Node.js</button>
                <button class="tab-button" onclick="switchTab(event, 'deposit-python')">Python</button>
                <button class="tab-button" onclick="switchTab(event, 'deposit-rust')">Rust</button>
                <button class="tab-button" onclick="switchTab(event, 'deposit-php')">PHP</button>
            </div>
            
            <div id="deposit-pseudocode" class="tab-content active">
                <div class="pseudocode-box">
                    <h4>🧠 Deposit Address Generation Logic</h4>
                    <pre><code>FUNCTION generateDepositAddress(userId):
    // Step 1: Input validation
    IF (userId IS empty OR userId IS invalid):
        THROW "Invalid user ID"
    
    // Step 2: Generate unique payment identifier
    timestamp = getCurrentTimestamp()
    randomBytes = generateSecureRandom(8) // 8 bytes = 64 bits
    paymentId = "deposit-" + userId + "-" + timestamp + "-" + randomBytes
    
    // Step 3: Convert payment ID to bytes for gRPC
    paymentIdBytes = convertToBytes(paymentId, "UTF-8")
    
    // Step 4: Call wallet gRPC to get address with payment ID
    request = {
        payment_id: paymentIdBytes
    }
    
    TRY:
        response = walletClient.GetPaymentIdAddress(request)
        
        // Step 5: Extract address information
        address = response.one_sided_address_base58
        emojiAddress = response.one_sided_address_emoji
        
        // Step 6: Store in database for tracking
        depositRecord = {
            userId: userId,
            paymentId: paymentId,
            address: address,
            status: "pending",
            createdAt: timestamp
        }
        
        database.save(depositRecord)
        
        // Step 7: Return deposit instructions to user
        RETURN {
            address: address,
            paymentId: paymentId,
            emojiAddress: emojiAddress,
            instructions: "Send XTM to this address with payment ID: " + paymentId,
            qrCode: generateQRCode(address, paymentId)
        }
        
    CATCH (grpcError):
        LOG "Failed to generate address: " + grpcError.message
        THROW "Address generation failed"</code></pre>
                </div>
            </div>
            
            <div id="deposit-grpcurl" class="tab-content">
                <div class="grpcurl-box">
                    <h4>🧪 Test Address Generation with grpcurl</h4>
                    <pre><code># First, get the exchange's main address (without payment ID)
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetCompleteAddress

# Generate address with specific payment ID
# Note: payment_id must be base64 encoded
PAYMENT_ID="deposit-user123-$(date +%s)-$(openssl rand -hex 4)"
PAYMENT_ID_B64=$(echo -n "$PAYMENT_ID" | base64 -w 0)

echo "Using Payment ID: $PAYMENT_ID"
echo "Base64 encoded: $PAYMENT_ID_B64"

grpcurl -plaintext \
  -d "{\"payment_id\": \"$PAYMENT_ID_B64\"}" \
  localhost:18143 \
  tari.rpc.Wallet/GetPaymentIdAddress

# Complete test script
#!/bin/bash
echo "=== Deposit Address Generation Test ==="

# Check if wallet is accessible
if ! grpcurl -plaintext -connect-timeout 5 localhost:18143 list > /dev/null 2>&1; then
    echo "❌ Wallet gRPC not accessible"
    exit 1
fi

# Generate unique payment ID
USER_ID="user123"
TIMESTAMP=$(date +%s)
RANDOM_HEX=$(openssl rand -hex 4)
PAYMENT_ID="deposit-${USER_ID}-${TIMESTAMP}-${RANDOM_HEX}"
PAYMENT_ID_B64=$(echo -n "$PAYMENT_ID" | base64 -w 0)

echo "✅ Generated Payment ID: $PAYMENT_ID"

# Get address with payment ID
echo "🔍 Requesting address from wallet..."
RESPONSE=$(grpcurl -plaintext \
  -d "{\"payment_id\": \"$PAYMENT_ID_B64\"}" \
  localhost:18143 \
  tari.rpc.Wallet/GetPaymentIdAddress 2>/dev/null)

if [ $? -eq 0 ]; then
    echo "✅ Address generated successfully"
    echo "$RESPONSE" | jq .
else
    echo "❌ Failed to generate address"
fi

# Test with authentication (if enabled)
AUTH_HEADER=$(echo -n "exchange_user:secure_password" | base64 -w 0)
grpcurl -plaintext \
  -H "authorization: Basic $AUTH_HEADER" \
  -d "{\"payment_id\": \"$PAYMENT_ID_B64\"}" \
  localhost:18143 \
  tari.rpc.Wallet/GetPaymentIdAddress</code></pre>
                </div>
            </div>
            
            <div id="deposit-nodejs" class="tab-content">
                <pre><code>const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');
const crypto = require('crypto');

class TariDepositManager {
    constructor() {
        // Load protobuf
        const packageDefinition = protoLoader.loadSync('./proto/wallet.proto', {
            keepCase: true,
            longs: String,
            enums: String,
            defaults: true,
            oneofs: true,
        });
        
        const walletProto = grpc.loadPackageDefinition(packageDefinition).tari.rpc;
        
        // Create authenticated client
        const credentials = grpc.credentials.createInsecure();
        this.client = new walletProto.Wallet('localhost:18143', credentials);
        
        // Add authentication metadata
        this.metadata = new grpc.Metadata();
        this.metadata.add('authorization', 'Basic ' + 
            Buffer.from('exchange_user:secure_password_here').toString('base64'));
    }
    
    async generateDepositAddress(userId) {
        // Generate unique payment ID
        const timestamp = Date.now();
        const randomHex = crypto.randomBytes(4).toString('hex');
        const paymentId = `deposit-${userId}-${timestamp}-${randomHex}`;
        const paymentIdBytes = Buffer.from(paymentId, 'utf8');
        
        return new Promise((resolve, reject) => {
            this.client.GetPaymentIdAddress(
                { payment_id: paymentIdBytes },
                this.metadata,
                (error, response) => {
                    if (error) {
                        reject(error);
                        return;
                    }
                    
                    // Store in database
                    this.storeDepositRecord(userId, paymentId);
                    
                    resolve({
                        address: response.one_sided_address_base58,
                        paymentId: paymentId,
                        emojiAddress: response.one_sided_address_emoji,
                        instructions: `Send XTM to ${response.one_sided_address_base58} with payment ID: ${paymentId}`,
                        qrCode: this.generateQRCode(response.one_sided_address_base58, paymentId)
                    });
                }
            );
        });
    }
    
    storeDepositRecord(userId, paymentId) {
        // Store in your database
        console.log(`Storing deposit record: User ${userId}, Payment ID ${paymentId}`);
        // Implementation depends on your database
    }
    
    generateQRCode(address, paymentId) {
        // Generate QR code for easy mobile scanning
        const tariUri = `tari:${address}?payment_id=${paymentId}`;
        return tariUri; // Return URI or actual QR code image
    }
}</code></pre>
            </div>
            
            <div id="deposit-python" class="tab-content">
                <pre><code>import grpc
import wallet_pb2
import wallet_pb2_grpc
import uuid
import base64
import time
from datetime import datetime

class TariDepositManager:
    def __init__(self):
        # Create gRPC channel
        self.channel = grpc.insecure_channel('localhost:18143')
        self.client = wallet_pb2_grpc.WalletStub(self.channel)
        
        # Authentication metadata
        auth_string = base64.b64encode(b'exchange_user:secure_password_here').decode('ascii')
        self.metadata = [('authorization', f'Basic {auth_string}')]
    
    def generate_deposit_address(self, user_id):
        """Generate a unique deposit address for a user"""
        
        # Generate unique payment ID
        timestamp = int(time.time())
        random_hex = uuid.uuid4().hex[:8]
        payment_id = f"deposit-{user_id}-{timestamp}-{random_hex}"
        payment_id_bytes = payment_id.encode('utf-8')
        
        try:
            # Get address with payment ID
            request = wallet_pb2.GetPaymentIdAddressRequest(payment_id=payment_id_bytes)
            response = self.client.GetPaymentIdAddress(request, metadata=self.metadata)
            
            # Store in database
            self.store_deposit_record(user_id, payment_id)
            
            return {
                'address': response.one_sided_address_base58,
                'payment_id': payment_id,
                'emoji_address': response.one_sided_address_emoji,
                'instructions': f'Send XTM to {response.one_sided_address_base58} with payment ID: {payment_id}',
                'qr_code': self.generate_qr_code(response.one_sided_address_base58, payment_id)
            }
            
        except grpc.RpcError as e:
            raise Exception(f"Failed to generate deposit address: {e.details()}")
    
    def store_deposit_record(self, user_id, payment_id):
        """Store deposit record in database"""
        # Implementation depends on your database
        print(f"Storing deposit record: User {user_id}, Payment ID {payment_id}")
        
    def generate_qr_code(self, address, payment_id):
        """Generate QR code URI for mobile wallets"""
        tari_uri = f"tari:{address}?payment_id={payment_id}"
        return tari_uri
        
    def close(self):
        self.channel.close()</code></pre>
            </div>
            
            <div id="deposit-rust" class="tab-content">
                <pre><code>use tonic::transport::Channel;
use tonic::metadata::MetadataValue;
use tonic::{Request, Status};
use uuid::Uuid;
use base64;
use chrono::Utc;

// Generated from proto files
pub mod tari_rpc {
    tonic::include_proto!("tari.rpc");
}

use tari_rpc::wallet_client::WalletClient;
use tari_rpc::{GetPaymentIdAddressRequest, GetCompleteAddressResponse};

pub struct TariDepositManager {
    client: WalletClient<Channel>,
}

impl TariDepositManager {
    pub async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let channel = Channel::from_static("http://127.0.0.1:18143").connect().await?;
        let client = WalletClient::new(channel);
        
        Ok(TariDepositManager { client })
    }
    
    pub async fn generate_deposit_address(&mut self, user_id: &str) -> Result<DepositInfo, Status> {
        // Generate unique payment ID
        let timestamp = Utc::now().timestamp();
        let random_hex = Uuid::new_v4().to_string()[..8].to_string();
        let payment_id = format!("deposit-{}-{}-{}", user_id, timestamp, random_hex);
        
        let payment_id_bytes = payment_id.as_bytes().to_vec();
        
        // Create authenticated request
        let mut request = Request::new(GetPaymentIdAddressRequest {
            payment_id: payment_id_bytes,
        });
        
        // Add authentication
        let auth_header = base64::encode("exchange_user:secure_password_here");
        let metadata_value = MetadataValue::from_str(&format!("Basic {}", auth_header))
            .map_err(|_| Status::invalid_argument("Invalid auth header"))?;
        request.metadata_mut().insert("authorization", metadata_value);
        
        // Make the request
        let response = self.client.get_payment_id_address(request).await?;
        let address_info = response.into_inner();
        
        // Store in database
        self.store_deposit_record(user_id, &payment_id).await?;
        
        Ok(DepositInfo {
            address: address_info.one_sided_address_base58,
            payment_id: payment_id.clone(),
            emoji_address: address_info.one_sided_address_emoji,
            instructions: format!("Send XTM to {} with payment ID: {}", 
                address_info.one_sided_address_base58, payment_id),
            qr_code: self.generate_qr_code(&address_info.one_sided_address_base58, &payment_id),
        })
    }
    
    async fn store_deposit_record(&self, user_id: &str, payment_id: &str) -> Result<(), Status> {
        // Implementation depends on your database
        println!("Storing deposit record: User {}, Payment ID {}", user_id, payment_id);
        Ok(())
    }
    
    fn generate_qr_code(&self, address: &str, payment_id: &str) -> String {
        format!("tari:{}?payment_id={}", address, payment_id)
    }
}

#[derive(Debug)]
pub struct DepositInfo {
    pub address: String,
    pub payment_id: String,
    pub emoji_address: String,
    pub instructions: String,
    pub qr_code: String,
}</code></pre>
            </div>
            
            <div id="deposit-php" class="tab-content">
                <pre><code><?php
require_once 'vendor/autoload.php';

use Tari\Rpc\WalletClient;
use Tari\Rpc\GetPaymentIdAddressRequest;
use Grpc\ChannelCredentials;

class TariDepositManager {
    private $client;
    private $metadata;
    
    public function __construct() {
        // Create gRPC client
        $this->client = new WalletClient('localhost:18143', [
            'credentials' => ChannelCredentials::createInsecure()
        ]);
        
        // Authentication metadata
        $authString = base64_encode('exchange_user:secure_password_here');
        $this->metadata = ['authorization' => ["Basic {$authString}"]];
    }
    
    public function generateDepositAddress($userId) {
        // Generate unique payment ID
        $timestamp = time();
        $randomHex = bin2hex(random_bytes(4));
        $paymentId = "deposit-{$userId}-{$timestamp}-{$randomHex}";
        
        $paymentIdBytes = $paymentId;
        
        try {
            // Create request
            $request = new GetPaymentIdAddressRequest([
                'payment_id' => $paymentIdBytes
            ]);
            
            // Make gRPC call
            list($response, $status) = $this->client->GetPaymentIdAddress(
                $request, 
                $this->metadata
            )->wait();
            
            if ($status->code !== Grpc\STATUS_OK) {
                throw new Exception("gRPC error: " . $status->details);
            }
            
            // Store in database
            $this->storeDepositRecord($userId, $paymentId);
            
            return [
                'address' => $response->getOneSidedAddressBase58(),
                'payment_id' => $paymentId,
                'emoji_address' => $response->getOneSidedAddressEmoji(),
                'instructions' => "Send XTM to {$response->getOneSidedAddressBase58()} with payment ID: {$paymentId}",
                'qr_code' => $this->generateQRCode($response->getOneSidedAddressBase58(), $paymentId)
            ];
            
        } catch (Exception $e) {
            throw new Exception("Failed to generate deposit address: " . $e->getMessage());
        }
    }
    
    private function storeDepositRecord($userId, $paymentId) {
        // Implementation depends on your database
        error_log("Storing deposit record: User {$userId}, Payment ID {$paymentId}");
    }
    
    private function generateQRCode($address, $paymentId) {
        return "tari:{$address}?payment_id={$paymentId}";
    }
}
?></code></pre>
            </div>
        </div>

        <h4><span class="step-number">2</span>Monitor for Incoming Transactions</h4>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'monitor-pseudocode')">Pseudocode</button>
                <button class="tab-button" onclick="switchTab(event, 'monitor-grpcurl')">grpcurl</button>
                <button class="tab-button" onclick="switchTab(event, 'monitor-nodejs')">Node.js</button>
                <button class="tab-button" onclick="switchTab(event, 'monitor-python')">Python</button>
                <button class="tab-button" onclick="switchTab(event, 'monitor-rust')">Rust</button>
                <button class="tab-button" onclick="switchTab(event, 'monitor-php')">PHP</button>
            </div>
            
            <div id="monitor-pseudocode" class="tab-content active">
                <div class="pseudocode-box">
                    <h4>🧠 Transaction Monitoring Logic</h4>
                    <pre><code>FUNCTION monitorIncomingTransactions():
    processedTransactions = loadProcessedTransactionsList()
    
    WHILE (service_is_running):
        TRY:
            // Method 1: Real-time streaming (preferred)
            IF (streaming_available):
                transactionStream = walletClient.StreamTransactionEvents()
                
                FOR EACH event IN transactionStream:
                    IF (event.type == "Mined" AND event.direction == "Inbound"):
                        processTransactionEvent(event)
            
            // Method 2: Polling (backup)
            ELSE:
                completedTransactions = walletClient.GetCompletedTransactions()
                
                FOR EACH transaction IN completedTransactions:
                    IF (shouldProcessTransaction(transaction)):
                        processTransaction(transaction)
        
        CATCH (connection_error):
            LOG "Connection lost, retrying in 5 seconds..."
            SLEEP(5)
            CONTINUE
        
        SLEEP(30) // Poll every 30 seconds if streaming not available

FUNCTION shouldProcessTransaction(transaction):
    RETURN (
        transaction.direction == "INBOUND" AND
        transaction.status == "CONFIRMED" AND
        NOT isAlreadyProcessed(transaction.tx_id)
    )

FUNCTION processTransaction(transaction):
    // Step 1: Extract and validate payment ID
    paymentId = extractPaymentIdFromBytes(transaction.payment_id)
    IF (paymentId IS empty):
        LOG "Transaction without payment ID: " + transaction.tx_id
        RETURN
    
    // Step 2: Look up deposit record
    depositRecord = database.findByPaymentId(paymentId)
    IF (depositRecord IS null):
        LOG "Unknown payment ID: " + paymentId
        RETURN
    
    // Step 3: Validate transaction amount
    amountXTM = transaction.amount / 1_000_000 // Convert microXTM to XTM
    IF (amountXTM < MINIMUM_DEPOSIT_AMOUNT):
        LOG "Deposit amount too small: " + amountXTM + " XTM"
        RETURN
    
    // Step 4: Credit user account
    TRY:
        accountBalance = getUserBalance(depositRecord.userId)
        newBalance = accountBalance + amountXTM
        
        // Atomic transaction
        BEGIN_DATABASE_TRANSACTION()
        
        updateUserBalance(depositRecord.userId, newBalance)
        markDepositAsProcessed(depositRecord.id, transaction.tx_id)
        createDepositHistoryRecord(depositRecord.userId, amountXTM, transaction.tx_id)
        
        COMMIT_DATABASE_TRANSACTION()
        
        // Step 5: Notify user
        sendDepositNotification(depositRecord.userId, amountXTM, transaction.tx_id)
        
        LOG "Processed deposit: " + amountXTM + " XTM for user " + depositRecord.userId
        
    CATCH (database_error):
        ROLLBACK_DATABASE_TRANSACTION()
        LOG "Failed to process deposit: " + database_error.message
        // Add to retry queue
    
    // Step 6: Mark as processed to avoid double-processing
    processedTransactions.add(transaction.tx_id)</code></pre>
                </div>
            </div>
            
            <div id="monitor-grpcurl" class="tab-content">
                <div class="grpcurl-box">
                    <h4>🧪 Test Transaction Monitoring with grpcurl</h4>
                    <pre><code># Method 1: Stream all completed transactions
echo "=== Streaming All Completed Transactions ==="
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetCompletedTransactions

# Method 2: Get transactions for specific payment ID
PAYMENT_ID="deposit-user123-1234567890-abcd1234"
PAYMENT_ID_B64=$(echo -n "$PAYMENT_ID" | base64 -w 0)

echo "=== Transactions for Payment ID: $PAYMENT_ID ==="
grpcurl -plaintext \
  -d "{\"payment_id\": {\"utf8_string\": \"$PAYMENT_ID\"}}" \
  localhost:18143 \
  tari.rpc.Wallet/GetCompletedTransactions

# Method 3: Stream real-time transaction events (preferred)
echo "=== Real-time Transaction Events ==="
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/StreamTransactionEvents

# Method 4: Get transactions for specific block
BLOCK_HASH="your_block_hash_here"
grpcurl -plaintext \
  -d "{\"block_hash\": {\"hash\": \"$BLOCK_HASH\"}}" \
  localhost:18143 \
  tari.rpc.Wallet/GetCompletedTransactions

# Complete monitoring test script
#!/bin/bash
echo "=== Transaction Monitoring Test ==="

# Check wallet connectivity
if ! grpcurl -plaintext -connect-timeout 5 localhost:18143 list > /dev/null 2>&1; then
    echo "❌ Wallet not accessible"
    exit 1
fi

echo "✅ Wallet accessible"

# Test 1: Get current wallet state
echo "📊 Current wallet state:"
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetState

# Test 2: Stream recent transactions (timeout after 10 seconds)
echo "📥 Streaming transactions for 10 seconds..."
timeout 10s grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetCompletedTransactions

# Test 3: Check for specific payment IDs in your database
echo "🔍 Testing specific payment ID lookup..."
# Replace with actual payment IDs from your database
for PAYMENT_ID in "deposit-test1" "deposit-test2"; do
    echo "Checking payment ID: $PAYMENT_ID"
    grpcurl -plaintext \
      -d "{\"payment_id\": {\"utf8_string\": \"$PAYMENT_ID\"}}" \
      localhost:18143 \
      tari.rpc.Wallet/GetCompletedTransactions | \
      jq '.transaction | select(.direction == "TRANSACTION_DIRECTION_INBOUND")'
done

# Test 4: Real-time monitoring simulation
echo "🔄 Starting real-time monitoring (Ctrl+C to stop)..."
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/StreamTransactionEvents | \
while read -r line; do
    echo "$(date): $line"
    # In real implementation, parse JSON and process transactions
done</code></pre>
                </div>
            </div>
            
            <div id="monitor-nodejs" class="tab-content">
                <pre><code>class TariDepositMonitor {
    constructor(depositManager) {
        this.depositManager = depositManager;
        this.processedTransactions = new Set();
        this.running = false;
    }
    
    startMonitoring() {
        this.running = true;
        console.log('Starting deposit monitoring...');
        
        // Option 1: Stream real-time events (preferred)
        this.streamTransactionEvents();
        
        // Option 2: Poll for completed transactions (backup)
        setInterval(() => {
            if (this.running) this.pollCompletedTransactions();
        }, 30000);
    }
    
    streamTransactionEvents() {
        const call = this.depositManager.client.StreamTransactionEvents(
            {}, 
            this.depositManager.metadata
        );
        
        call.on('data', (response) => {
            if (response.transaction) {
                this.processTransactionEvent(response.transaction);
            }
        });
        
        call.on('error', (err) => {
            console.error('Stream error:', err);
            // Restart stream after delay
            setTimeout(() => {
                if (this.running) this.streamTransactionEvents();
            }, 5000);
        });
        
        call.on('end', () => {
            console.log('Stream ended, restarting...');
            if (this.running) {
                setTimeout(() => this.streamTransactionEvents(), 1000);
            }
        });
    }
    
    async pollCompletedTransactions() {
        try {
            const call = this.depositManager.client.GetCompletedTransactions(
                {}, 
                this.depositManager.metadata
            );
            
            call.on('data', (response) => {
                if (response.transaction) {
                    this.processTransaction(response.transaction);
                }
            });
            
        } catch (error) {
            console.error('Error polling transactions:', error);
        }
    }
    
    processTransactionEvent(event) {
        // Process real-time events
        if (event.event === 'Mined' && event.direction === 'Inbound') {
            // Get full transaction details if needed
            const txId = parseInt(event.tx_id);
            this.getAndProcessTransaction(txId);
        }
    }
    
    async processTransaction(transaction) {
        // Only process inbound, confirmed transactions
        if (transaction.direction !== 'TRANSACTION_DIRECTION_INBOUND' ||
            transaction.status !== 'TRANSACTION_STATUS_MINED_CONFIRMED' ||
            this.processedTransactions.has(transaction.tx_id)) {
            return;
        }
        
        try {
            // Extract payment ID
            const paymentId = Buffer.from(transaction.payment_id).toString('utf8');
            
            if (!paymentId) {
                console.log(`Transaction ${transaction.tx_id} has no payment ID`);
                return;
            }
            
            // Look up deposit record
            const depositRecord = await this.findDepositRecord(paymentId);
            
            if (!depositRecord) {
                console.log(`Unknown payment ID: ${paymentId}`);
                return;
            }
            
            // Validate amount
            const amountXTM = parseInt(transaction.amount) / 1_000_000;
            if (amountXTM < 0.001) { // Minimum deposit
                console.log(`Deposit amount too small: ${amountXTM} XTM`);
                return;
            }
            
            // Credit user account (with database transaction)
            await this.creditUserAccount(
                depositRecord.userId,
                amountXTM,
                transaction.tx_id,
                paymentId
            );
            
            // Mark as processed
            this.processedTransactions.add(transaction.tx_id);
            
            console.log(`✅ Processed deposit: ${amountXTM} XTM for user ${depositRecord.userId}`);
            
        } catch (error) {
            console.error('Error processing transaction:', error);
        }
    }
    
    async findDepositRecord(paymentId) {
        // Query your database for the payment ID
        // Return { userId, paymentId, status } or null
        console.log(`Looking up payment ID: ${paymentId}`);
        return null; // Placeholder - implement your database query
    }
    
    async creditUserAccount(userId, amount, txId, paymentId) {
        // Implement atomic database transaction
        try {
            // 1. Start database transaction
            // 2. Update user balance
            // 3. Create deposit history record
            // 4. Mark deposit as processed
            // 5. Commit transaction
            // 6. Send user notification
            
            console.log(`Crediting user ${userId} with ${amount} XTM (tx: ${txId})`);
            
        } catch (error) {
            // Rollback transaction
            throw error;
        }
    }
    
    stopMonitoring() {
        this.running = false;
        console.log('Deposit monitoring stopped');
    }
}</code></pre>
            </div>
            
            <div id="monitor-python" class="tab-content">
                <pre><code>import asyncio
import threading
import time
import json
from typing import Optional, Dict, Set

class TariDepositMonitor:
    def __init__(self, deposit_manager):
        self.deposit_manager = deposit_manager
        self.processed_transactions: Set[int] = set()
        self.running = False
    
    def start_monitoring(self):
        """Start monitoring for deposits"""
        self.running = True
        
        # Start real-time event streaming in separate thread
        stream_thread = threading.Thread(target=self.stream_transaction_events)
        stream_thread.daemon = True
        stream_thread.start()
        
        # Start polling backup in separate thread
        poll_thread = threading.Thread(target=self.poll_completed_transactions)
        poll_thread.daemon = True
        poll_thread.start()
        
        print("✅ Deposit monitoring started")
    
    def stream_transaction_events(self):
        """Stream real-time transaction events"""
        while self.running:
            try:
                request = wallet_pb2.TransactionEventRequest()
                
                for response in self.deposit_manager.client.StreamTransactionEvents(
                    request, metadata=self.deposit_manager.metadata
                ):
                    if not self.running:
                        break
                    
                    if response.transaction:
                        self.process_transaction_event(response.transaction)
                        
            except grpc.RpcError as e:
                print(f"Stream error: {e}, retrying in 5 seconds...")
                time.sleep(5)
    
    def poll_completed_transactions(self):
        """Poll for completed transactions as backup"""
        while self.running:
            try:
                request = wallet_pb2.GetCompletedTransactionsRequest()
                
                for response in self.deposit_manager.client.GetCompletedTransactions(
                    request, metadata=self.deposit_manager.metadata
                ):
                    if not self.running:
                        break
                    
                    if response.transaction:
                        self.process_transaction(response.transaction)
                        
            except grpc.RpcError as e:
                print(f"Poll error: {e}")
            
            time.sleep(30)  # Poll every 30 seconds
    
    def process_transaction_event(self, transaction_event):
        """Process a real-time transaction event"""
        if (transaction_event.event == "Mined" and 
            transaction_event.direction == "Inbound"):
            
            # Get full transaction details if needed
            tx_id = int(transaction_event.tx_id)
            self.get_and_process_transaction(tx_id)
    
    def process_transaction(self, transaction):
        """Process a completed transaction"""
        # Only process inbound, confirmed transactions
        if (transaction.direction != wallet_pb2.TRANSACTION_DIRECTION_INBOUND or
            transaction.status != wallet_pb2.TRANSACTION_STATUS_MINED_CONFIRMED or
            transaction.tx_id in self.processed_transactions):
            return
        
        try:
            # Extract payment ID
            payment_id = transaction.payment_id.decode('utf-8', errors='replace')
            
            if not payment_id:
                print(f"Transaction {transaction.tx_id} has no payment ID")
                return
            
            # Look up deposit record
            deposit_record = self.find_deposit_record(payment_id)
            
            if not deposit_record:
                print(f"Unknown payment ID: {payment_id}")
                return
            
            # Validate amount
            amount_xtm = transaction.amount / 1_000_000
            if amount_xtm < 0.001:  # Minimum deposit
                print(f"Deposit amount too small: {amount_xtm} XTM")
                return
            
            # Credit user account
            self.credit_user_account(
                deposit_record['user_id'],
                amount_xtm,
                transaction.tx_id,
                payment_id
            )
            
            # Mark as processed
            self.processed_transactions.add(transaction.tx_id)
            
            print(f"✅ Processed deposit: {amount_xtm} XTM for user {deposit_record['user_id']}")
            
        except Exception as e:
            print(f"Error processing transaction: {e}")
    
    def find_deposit_record(self, payment_id: str) -> Optional[Dict]:
        """Find deposit record by payment ID"""
        # Query your database
        print(f"Looking up payment ID: {payment_id}")
        return None  # Placeholder - implement your database query
    
    def credit_user_account(self, user_id: str, amount: float, tx_id: int, payment_id: str):
        """Credit user's account with atomic database transaction"""
        try:
            # 1. Start database transaction
            # 2. Update user balance  
            # 3. Create deposit history record
            # 4. Mark deposit as processed
            # 5. Commit transaction
            # 6. Send user notification
            
            print(f"Crediting user {user_id} with {amount} XTM (tx: {tx_id})")
            
        except Exception as error:
            # Rollback transaction
            print(f"Failed to credit account: {error}")
            raise
    
    def stop_monitoring(self):
        """Stop monitoring"""
        self.running = False
        print("Deposit monitoring stopped")</code></pre>
            </div>
            
            <div id="monitor-rust" class="tab-content">
                <pre><code>use tokio::time::{interval, Duration};
use tokio::sync::mpsc;
use std::collections::HashSet;
use tonic::Request;

pub struct TariDepositMonitor {
    deposit_manager: TariDepositManager,
    processed_transactions: HashSet<u64>,
    running: bool,
}

impl TariDepositMonitor {
    pub fn new(deposit_manager: TariDepositManager) -> Self {
        Self {
            deposit_manager,
            processed_transactions: HashSet::new(),
            running: false,
        }
    }
    
    pub async fn start_monitoring(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        self.running = true;
        println!("✅ Starting deposit monitoring...");
        
        // Channel for communication between tasks
        let (tx, mut rx) = mpsc::channel(100);
        
        // Start real-time event streaming
        let stream_tx = tx.clone();
        let mut stream_client = self.deposit_manager.client.clone();
        tokio::spawn(async move {
            Self::stream_transaction_events(stream_client, stream_tx).await;
        });
        
        // Start polling backup
        let poll_tx = tx.clone();
        let mut poll_client = self.deposit_manager.client.clone();
        tokio::spawn(async move {
            Self::poll_completed_transactions(poll_client, poll_tx).await;
        });
        
        // Process incoming transactions
        while let Some(transaction) = rx.recv().await {
            if !self.running {
                break;
            }
            self.process_transaction(transaction).await?;
        }
        
        Ok(())
    }
    
    async fn stream_transaction_events(
        mut client: WalletClient<Channel>,
        tx: mpsc::Sender<TransactionInfo>
    ) {
        loop {
            match client.stream_transaction_events(Request::new(tari_rpc::TransactionEventRequest {})).await {
                Ok(mut stream) => {
                    while let Some(response) = stream.get_mut().message().await.ok().flatten() {
                        if let Some(transaction_event) = response.transaction {
                            if transaction_event.event == "Mined" && 
                               transaction_event.direction == "Inbound" {
                                // Would need to fetch full transaction details here
                                // and send via tx.send(transaction_info).await
                            }
                        }
                    }
                }
                Err(e) => {
                    eprintln!("Stream error: {}, retrying in 5 seconds...", e);
                    tokio::time::sleep(Duration::from_secs(5)).await;
                }
            }
        }
    }
    
    async fn poll_completed_transactions(
        mut client: WalletClient<Channel>,
        tx: mpsc::Sender<TransactionInfo>
    ) {
        let mut interval = interval(Duration::from_secs(30));
        
        loop {
            interval.tick().await;
            
            match client.get_completed_transactions(Request::new(tari_rpc::GetCompletedTransactionsRequest {})).await {
                Ok(mut stream) => {
                    while let Some(response) = stream.get_mut().message().await.ok().flatten() {
                        if let Some(transaction) = response.transaction {
                            let _ = tx.send(transaction).await;
                        }
                    }
                }
                Err(e) => {
                    eprintln!("Poll error: {}", e);
                }
            }
        }
    }
    
    async fn process_transaction(&mut self, transaction: TransactionInfo) -> Result<(), Box<dyn std::error::Error>> {
        // Only process inbound, confirmed transactions
        if transaction.direction != 1 || // TRANSACTION_DIRECTION_INBOUND
           transaction.status != 6 || // TRANSACTION_STATUS_MINED_CONFIRMED
           self.processed_transactions.contains(&transaction.tx_id) {
            return Ok(());
        }
        
        // Extract payment ID
        let payment_id = String::from_utf8_lossy(&transaction.payment_id);
        
        if payment_id.is_empty() {
            println!("Transaction {} has no payment ID", transaction.tx_id);
            return Ok(());
        }
        
        // Look up deposit record
        if let Some(deposit_record) = self.find_deposit_record(&payment_id).await? {
            // Validate amount
            let amount_xtm = transaction.amount as f64 / 1_000_000.0;
            if amount_xtm < 0.001 {
                println!("Deposit amount too small: {} XTM", amount_xtm);
                return Ok(());
            }
            
            // Credit user account
            self.credit_user_account(
                &deposit_record.user_id,
                amount_xtm,
                transaction.tx_id,
                &payment_id
            ).await?;
            
            // Mark as processed
            self.processed_transactions.insert(transaction.tx_id);
            
            println!("✅ Processed deposit: {} XTM for user {}", 
                amount_xtm, deposit_record.user_id);
        } else {
            println!("Unknown payment ID: {}", payment_id);
        }
        
        Ok(())
    }
    
    async fn find_deposit_record(&self, payment_id: &str) -> Result<Option<DepositRecord>, Box<dyn std::error::Error>> {
        // Query your database
        println!("Looking up payment ID: {}", payment_id);
        Ok(None) // Placeholder - implement your database query
    }
    
    async fn credit_user_account(&self, user_id: &str, amount: f64, tx_id: u64, payment_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        // Implement atomic database transaction
        println!("Crediting user {} with {} XTM (tx: {})", user_id, amount, tx_id);
        Ok(())
    }
    
    pub fn stop_monitoring(&mut self) {
        self.running = false;
        println!("Deposit monitoring stopped");
    }
}

#[derive(Debug)]
struct DepositRecord {
    user_id: String,
    payment_id: String,
}</code></pre>
            </div>
            
            <div id="monitor-php" class="tab-content">
                <pre><code><?php

class TariDepositMonitor {
    private $depositManager;
    private $processedTransactions = [];
    private $running = false;
    
    public function __construct(TariDepositManager $depositManager) {
        $this->depositManager = $depositManager;
    }
    
    public function startMonitoring() {
        $this->running = true;
        echo "✅ Starting deposit monitoring...\n";
        
        // Start monitoring in a loop
        while ($this->running) {
            try {
                $this->pollCompletedTransactions();
                sleep(30); // Poll every 30 seconds
            } catch (Exception $e) {
                error_log("Monitoring error: " . $e->getMessage());
                sleep(5); // Wait before retrying
            }
        }
    }
    
    private function pollCompletedTransactions() {
        $request = new \Tari\Rpc\GetCompletedTransactionsRequest();
        
        try {
            list($stream, $status) = $this->depositManager->client->GetCompletedTransactions(
                $request,
                $this->depositManager->metadata
            );
            
            if ($status->code !== Grpc\STATUS_OK) {
                throw new Exception("gRPC error: " . $status->details);
            }
            
            // Process each transaction in the stream
            foreach ($stream->responses() as $response) {
                if ($response && $response->getTransaction()) {
                    $this->processTransaction($response->getTransaction());
                }
            }
            
        } catch (Exception $e) {
            error_log("Error polling transactions: " . $e->getMessage());
        }
    }
    
    private function processTransaction($transaction) {
        // Only process inbound, confirmed transactions
        if ($transaction->getDirection() !== \Tari\Rpc\TransactionDirection::TRANSACTION_DIRECTION_INBOUND ||
            $transaction->getStatus() !== \Tari\Rpc\TransactionStatus::TRANSACTION_STATUS_MINED_CONFIRMED ||
            in_array($transaction->getTxId(), $this->processedTransactions)) {
            return;
        }
        
        try {
            // Extract payment ID
            $paymentId = $transaction->getPaymentId();
            
            if (empty($paymentId)) {
                error_log("Transaction {$transaction->getTxId()} has no payment ID");
                return;
            }
            
            // Look up deposit record
            $depositRecord = $this->findDepositRecord($paymentId);
            
            if (!$depositRecord) {
                error_log("Unknown payment ID: {$paymentId}");
                return;
            }
            
            // Validate amount
            $amountXTM = $transaction->getAmount() / 1_000_000;
            if ($amountXTM < 0.001) { // Minimum deposit
                error_log("Deposit amount too small: {$amountXTM} XTM");
                return;
            }
            
            // Credit user account
            $this->creditUserAccount(
                $depositRecord['user_id'],
                $amountXTM,
                $transaction->getTxId(),
                $paymentId
            );
            
            // Mark as processed
            $this->processedTransactions[] = $transaction->getTxId();
            
            echo "✅ Processed deposit: {$amountXTM} XTM for user {$depositRecord['user_id']}\n";
            
        } catch (Exception $e) {
            error_log("Error processing transaction: " . $e->getMessage());
        }
    }
    
    private function findDepositRecord($paymentId) {
        // Query your database for the payment ID
        error_log("Looking up payment ID: {$paymentId}");
        return null; // Placeholder - implement your database query
    }
    
    private function creditUserAccount($userId, $amount, $txId, $paymentId) {
        try {
            // 1. Start database transaction
            // 2. Update user balance
            // 3. Create deposit history record
            // 4. Mark deposit as processed
            // 5. Commit transaction
            // 6. Send user notification
            
            error_log("Crediting user {$userId} with {$amount} XTM (tx: {$txId})");
            
        } catch (Exception $error) {
            // Rollback transaction
            error_log("Failed to credit account: " . $error->getMessage());
            throw $error;
        }
    }
    
    public function stopMonitoring() {
        $this->running = false;
        echo "Deposit monitoring stopped\n";
    }
}
?></code></pre>
            </div>
        </div>

        <h2 id="withdrawal-processing">💸 6. Withdrawal Processing</h2>

        <div class="warning">
            <strong>🔐 Security Alert:</strong> Withdrawal processing involves the cold storage wallet. Implement proper authorization, rate limiting, and multi-signature approval processes.
        </div>

        <h3>🔄 Withdrawal Flow</h3>

        <div class="architecture-diagram">
            <div>
                <div class="flow-box">User Requests<br/>Withdrawal</div>
                <span class="arrow">→</span>
                <div class="flow-box">Exchange Validates<br/>Request</div>
                <span class="arrow">→</span>
                <div class="flow-box">Authorization<br/>Required</div>
            </div>
            <div style="margin: 20px 0;">
                <div class="flow-box">Transaction<br/>Broadcast</div>
                <span class="arrow">←</span>
                <div class="flow-box">Cold Wallet<br/>Signs</div>
                <span class="arrow">←</span>
                <div class="flow-box">Approved<br/>& Queued</div>
            </div>
        </div>

        <h4><span class="step-number">1</span>Validate Withdrawal Request</h4>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'withdraw-pseudocode')">Pseudocode</button>
                <button class="tab-button" onclick="switchTab(event, 'withdraw-grpcurl')">grpcurl</button>
                <button class="tab-button" onclick="switchTab(event, 'withdraw-nodejs')">Node.js</button>
                <button class="tab-button" onclick="switchTab(event, 'withdraw-python')">Python</button>
                <button class="tab-button" onclick="switchTab(event, 'withdraw-rust')">Rust</button>
                <button class="tab-button" onclick="switchTab(event, 'withdraw-php')">PHP</button>
            </div>
            
            <div id="withdraw-pseudocode" class="tab-content active">
                <div class="pseudocode-box">
                    <h4>🧠 Withdrawal Validation Logic</h4>
                    <pre><code>FUNCTION validateWithdrawalRequest(userId, destinationAddress, amount):
    // Step 1: Validate user authentication and KYC status
    user = database.getUser(userId)
    IF (user IS null):
        THROW "User not found"
    
    IF (NOT user.isKYCVerified):
        THROW "User not KYC verified"
    
    IF (user.isBlocked OR user.withdrawalsSuspended):
        THROW "User account restricted"
    
    // Step 2: Validate withdrawal amount
    IF (amount <= 0):
        THROW "Invalid withdrawal amount"
    
    minimumWithdrawal = getMinimumWithdrawalAmount()
    IF (amount < minimumWithdrawal):
        THROW "Amount below minimum withdrawal: " + minimumWithdrawal + " XTM"
    
    // Step 3: Check user balance (including fees)
    withdrawalFee = calculateWithdrawalFee(amount)
    totalRequired = amount + withdrawalFee
    
    IF (user.availableBalance < totalRequired):
        THROW "Insufficient balance. Required: " + totalRequired + " XTM, Available: " + user.availableBalance + " XTM"
    
    // Step 4: Validate destination address
    IF (NOT isValidTariAddress(destinationAddress)):
        THROW "Invalid Tari address format"
    
    // Step 5: Check if address is interactive (not allowed for exchanges)
    IF (isInteractiveAddress(destinationAddress)):
        THROW "Interactive addresses not supported for withdrawals"
    
    // Step 6: Security checks
    IF (isBlacklistedAddress(destinationAddress)):
        THROW "Destination address is blacklisted"
    
    // Step 7: Rate limiting and daily limits
    dailyWithdrawalLimit = getDailyWithdrawalLimit(user.kycLevel)
    todayWithdrawals = getTodayWithdrawals(userId)
    
    IF (todayWithdrawals + amount > dailyWithdrawalLimit):
        THROW "Daily withdrawal limit exceeded"
    
    // Step 8: Check for suspicious activity
    IF (detectSuspiciousActivity(userId, amount, destinationAddress)):
        THROW "Withdrawal flagged for manual review"
    
    // Step 9: Create withdrawal record
    withdrawalId = generateUniqueId()
    withdrawalRecord = {
        id: withdrawalId,
        userId: userId,
        destinationAddress: destinationAddress,
        amount: amount,
        fee: withdrawalFee,
        status: "pending_approval",
        createdAt: getCurrentTimestamp(),
        approvalRequired: (amount > getManualApprovalThreshold())
    }
    
    database.saveWithdrawal(withdrawalRecord)
    
    // Step 10: Reserve user balance
    database.reserveUserBalance(userId, totalRequired)
    
    RETURN {
        withdrawalId: withdrawalId,
        amount: amount,
        fee: withdrawalFee,
        estimatedProcessingTime: "15-30 minutes",
        approvalRequired: withdrawalRecord.approvalRequired
    }</code></pre>
                </div>
            </div>
            
            <div id="withdraw-grpcurl" class="tab-content">
                <div class="grpcurl-box">
                    <h4>🧪 Test Withdrawal with grpcurl</h4>
                    <pre><code># Step 1: Check wallet balance before withdrawal
echo "=== Checking Wallet Balance ==="
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetBalance

# Step 2: Get wallet state to ensure sync
echo "=== Checking Wallet State ==="
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetState

# Step 3: Send test withdrawal (ONE_SIDED transaction)
echo "=== Sending Test Withdrawal ==="

# Important: Replace with actual test addresses
RECIPIENT_ADDRESS="12HVCEeZC2RGE4SDn3yGwqz..." # One-sided address only
AMOUNT=1000000  # 1 XTM in microXTM
FEE_PER_GRAM=25
PAYMENT_ID="withdraw-test-$(date +%s)"
PAYMENT_ID_B64=$(echo -n "$PAYMENT_ID" | base64 -w 0)

grpcurl -plaintext \
  -d "{
    \"recipients\": [{
      \"address\": \"$RECIPIENT_ADDRESS\",
      \"amount\": $AMOUNT,
      \"fee_per_gram\": $FEE_PER_GRAM,
      \"payment_type\": \"ONE_SIDED\",
      \"payment_id\": \"$PAYMENT_ID_B64\"
    }]
  }" \
  localhost:18143 \
  tari.rpc.Wallet/Transfer

# Step 4: Check transaction status
echo "=== Checking Recent Transactions ==="
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetCompletedTransactions | \
  jq '.transaction | select(.direction == "TRANSACTION_DIRECTION_OUTBOUND")' | head -20

# Complete withdrawal test script
#!/bin/bash
echo "=== Withdrawal Test Script ==="

# Configuration
RECIPIENT_ADDRESS="${1:-}"
AMOUNT="${2:-1000000}"  # Default 1 XTM
FEE_PER_GRAM=25

if [ -z "$RECIPIENT_ADDRESS" ]; then
    echo "Usage: $0 <recipient_address> [amount_in_microxtm]"
    echo "Example: $0 12HVCEeZC2RGE4SDn3yGwqz... 1000000"
    exit 1
fi

# Validate address format (basic check)
if [ ${#RECIPIENT_ADDRESS} -lt 50 ]; then
    echo "❌ Address too short (must be 50+ characters)"
    exit 1
fi

# Check wallet connectivity
if ! grpcurl -plaintext -connect-timeout 5 localhost:18143 list > /dev/null 2>&1; then
    echo "❌ Wallet not accessible"
    exit 1
fi

echo "✅ Wallet accessible"

# Check balance
echo "📊 Checking balance..."
BALANCE_RESPONSE=$(grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetBalance 2>/dev/null)
AVAILABLE_BALANCE=$(echo "$BALANCE_RESPONSE" | jq -r '.available_balance // 0')

echo "Available balance: $AVAILABLE_BALANCE microXTM"

# Calculate total required (amount + estimated fee)
ESTIMATED_FEE=$((FEE_PER_GRAM * 200))  # Rough estimate
TOTAL_REQUIRED=$((AMOUNT + ESTIMATED_FEE))

if [ "$AVAILABLE_BALANCE" -lt "$TOTAL_REQUIRED" ]; then
    echo "❌ Insufficient balance. Required: $TOTAL_REQUIRED, Available: $AVAILABLE_BALANCE"
    exit 1
fi

echo "✅ Sufficient balance"

# Generate payment ID
PAYMENT_ID="withdraw-test-$(date +%s)-$(openssl rand -hex 4)"
PAYMENT_ID_B64=$(echo -n "$PAYMENT_ID" | base64 -w 0)

echo "🔍 Payment ID: $PAYMENT_ID"

# Send withdrawal
echo "💸 Sending withdrawal..."
WITHDRAW_RESPONSE=$(grpcurl -plaintext \
  -d "{
    \"recipients\": [{
      \"address\": \"$RECIPIENT_ADDRESS\",
      \"amount\": $AMOUNT,
      \"fee_per_gram\": $FEE_PER_GRAM,
      \"payment_type\": \"ONE_SIDED\",
      \"payment_id\": \"$PAYMENT_ID_B64\"
    }]
  }" \
  localhost:18143 \
  tari.rpc.Wallet/Transfer 2>/dev/null)

if [ $? -eq 0 ]; then
    echo "✅ Withdrawal sent successfully"
    echo "$WITHDRAW_RESPONSE" | jq .
    
    # Extract transaction ID for tracking
    TX_ID=$(echo "$WITHDRAW_RESPONSE" | jq -r '.results[0].transaction_id // empty')
    if [ -n "$TX_ID" ]; then
        echo "📋 Transaction ID: $TX_ID"
        
        # Get transaction details
        echo "🔍 Getting transaction details..."
        grpcurl -plaintext \
          -d "{\"transaction_ids\": [$TX_ID]}" \
          localhost:18143 \
          tari.rpc.Wallet/GetTransactionInfo
    fi
else
    echo "❌ Withdrawal failed"
fi</code></pre>
                </div>
            </div>
            
            <div id="withdraw-nodejs" class="tab-content">
                <pre><code>class TariWithdrawalManager {
    constructor(walletClient, metadata) {
        this.walletClient = walletClient;
        this.metadata = metadata;
        this.MIN_WITHDRAWAL = 1000000; // 1 XTM in microXTM
        this.WITHDRAWAL_FEE = 25000;   // 0.025 XTM
        this.MANUAL_APPROVAL_THRESHOLD = 100000000000; // 100,000 XTM
    }
    
    async validateWithdrawalRequest(userId, destinationAddress, amount) {
        try {
            // Step 1: Validate user
            const user = await this.getUser(userId);
            if (!user) {
                throw new Error('User not found');
            }
            
            if (!user.isKYCVerified) {
                throw new Error('User not KYC verified');
            }
            
            if (user.isBlocked || user.withdrawalsSuspended) {
                throw new Error('User account restricted');
            }
            
            // Step 2: Validate amount
            if (amount <= 0 || amount < this.MIN_WITHDRAWAL) {
                throw new Error(`Amount below minimum withdrawal: ${this.MIN_WITHDRAWAL / 1000000} XTM`);
            }
            
            // Step 3: Check user balance
            const withdrawalFee = this.calculateWithdrawalFee(amount);
            const totalRequired = amount + withdrawalFee;
            
            if (user.availableBalance < totalRequired) {
                throw new Error(`Insufficient balance. Required: ${totalRequired / 1000000} XTM, Available: ${user.availableBalance / 1000000} XTM`);
            }
            
            // Step 4: Validate address
            if (!this.isValidTariAddress(destinationAddress)) {
                throw new Error('Invalid Tari address format');
            }
            
            if (this.isInteractiveAddress(destinationAddress)) {
                throw new Error('Interactive addresses not supported for withdrawals');
            }
            
            // Step 5: Security checks
            if (await this.isBlacklistedAddress(destinationAddress)) {
                throw new Error('Destination address is blacklisted');
            }
            
            // Step 6: Rate limiting
            if (await this.exceedsWithdrawalLimits(userId, amount)) {
                throw new Error('Withdrawal limits exceeded');
            }
            
            // Step 7: Detect suspicious activity
            if (await this.detectSuspiciousActivity(userId, amount, destinationAddress)) {
                throw new Error('Withdrawal flagged for manual review');
            }
            
            // Step 8: Create withdrawal record
            const withdrawalId = this.generateWithdrawalId();
            const approvalRequired = amount > this.MANUAL_APPROVAL_THRESHOLD;
            
            const withdrawalRecord = {
                id: withdrawalId,
                userId: userId,
                destinationAddress: destinationAddress,
                amount: amount,
                fee: withdrawalFee,
                status: 'pending_approval',
                createdAt: new Date(),
                approvalRequired: approvalRequired
            };
            
            await this.saveWithdrawal(withdrawalRecord);
            
            // Step 9: Reserve user balance
            await this.reserveUserBalance(userId, totalRequired);
            
            return {
                withdrawalId: withdrawalId,
                amount: amount,
                fee: withdrawalFee,
                estimatedProcessingTime: '15-30 minutes',
                approvalRequired: approvalRequired
            };
            
        } catch (error) {
            throw new Error(`Withdrawal validation failed: ${error.message}`);
        }
    }
    
    isValidTariAddress(address) {
        // Basic Tari address validation
        const base58Regex = /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/;
        return base58Regex.test(address) && address.length >= 50 && address.length <= 70;
    }
    
    isInteractiveAddress(address) {
        try {
            // Decode base58 and check the address type byte
            const decoded = this.base58Decode(address);
            if (decoded.length < 2) return false;
            
            // Check the second byte (address type)
            // IMPORTANT: This logic must match official Tari address specification            // 0x01 = interactive, 0x00 = one-sided
            return (decoded[1] & 0x01) === 0x01;
        } catch {
            return false;
        }
    }
    
    calculateWithdrawalFee(amount) {
        // Simple flat fee for now, could be percentage-based
        return this.WITHDRAWAL_FEE;
    }
    
    async exceedsWithdrawalLimits(userId, amount) {
        const dailyLimit = 100000000000; // 100,000 XTM
        const hourlyLimit = 10000000000; // 10,000 XTM
        
        const todayWithdrawals = await this.getTodayWithdrawals(userId);
        const hourlyWithdrawals = await this.getHourlyWithdrawals(userId);
        
        const dailyTotal = todayWithdrawals.reduce((sum, w) => sum + w.amount, 0);
        const hourlyTotal = hourlyWithdrawals.reduce((sum, w) => sum + w.amount, 0);
        
        return (dailyTotal + amount > dailyLimit) || (hourlyTotal + amount > hourlyLimit);
    }
    
    async detectSuspiciousActivity(userId, amount, destinationAddress) {
        // Implement your fraud detection logic
        // Examples:
        // - Multiple withdrawals to same address
        // - Withdrawal immediately after deposit
        // - Unusual withdrawal patterns
        // - Address appears in fraud database
        
        return false; // Placeholder
    }
    
    generateWithdrawalId() {
        return `withdraw_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // Database helper methods (implement based on your database)
    async getUser(userId) { /* Implementation */ }
    async saveWithdrawal(record) { /* Implementation */ }
    async reserveUserBalance(userId, amount) { /* Implementation */ }
    async getTodayWithdrawals(userId) { /* Implementation */ }
    async getHourlyWithdrawals(userId) { /* Implementation */ }
    async isBlacklistedAddress(address) { /* Implementation */ }
}</code></pre>
            </div>
            
            <div id="withdraw-python" class="tab-content">
                <pre><code>import re
import base58
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional

class TariWithdrawalManager:
    def __init__(self, wallet_client, metadata):
        self.wallet_client = wallet_client
        self.metadata = metadata
        self.MIN_WITHDRAWAL = 1_000_000  # 1 XTM in microXTM
        self.WITHDRAWAL_FEE = 25_000     # 0.025 XTM
        self.MANUAL_APPROVAL_THRESHOLD = 100_000_000_000  # 100,000 XTM
    
    async def validate_withdrawal_request(self, user_id: str, destination_address: str, amount: int) -> Dict:
        """Validate a withdrawal request and return withdrawal details"""
        try:
            # Step 1: Validate user
            user = await self.get_user(user_id)
            if not user:
                raise ValueError('User not found')
            
            if not user.get('is_kyc_verified'):
                raise ValueError('User not KYC verified')
            
            if user.get('is_blocked') or user.get('withdrawals_suspended'):
                raise ValueError('User account restricted')
            
            # Step 2: Validate amount
            if amount <= 0 or amount < self.MIN_WITHDRAWAL:
                raise ValueError(f'Amount below minimum withdrawal: {self.MIN_WITHDRAWAL / 1_000_000} XTM')
            
            # Step 3: Check user balance
            withdrawal_fee = self.calculate_withdrawal_fee(amount)
            total_required = amount + withdrawal_fee
            
            if user['available_balance'] < total_required:
                raise ValueError(f'Insufficient balance. Required: {total_required / 1_000_000} XTM, '
                               f'Available: {user["available_balance"] / 1_000_000} XTM')
            
            # Step 4: Validate address
            if not self.is_valid_tari_address(destination_address):
                raise ValueError('Invalid Tari address format')
            
            if self.is_interactive_address(destination_address):
                raise ValueError('Interactive addresses not supported for withdrawals')
            
            # Step 5: Security checks
            if await self.is_blacklisted_address(destination_address):
                raise ValueError('Destination address is blacklisted')
            
            # Step 6: Rate limiting
            if await self.exceeds_withdrawal_limits(user_id, amount):
                raise ValueError('Withdrawal limits exceeded')
            
            # Step 7: Detect suspicious activity
            if await self.detect_suspicious_activity(user_id, amount, destination_address):
                raise ValueError('Withdrawal flagged for manual review')
            
            # Step 8: Create withdrawal record
            withdrawal_id = self.generate_withdrawal_id()
            approval_required = amount > self.MANUAL_APPROVAL_THRESHOLD
            
            withdrawal_record = {
                'id': withdrawal_id,
                'user_id': user_id,
                'destination_address': destination_address,
                'amount': amount,
                'fee': withdrawal_fee,
                'status': 'pending_approval',
                'created_at': datetime.now(),
                'approval_required': approval_required
            }
            
            await self.save_withdrawal(withdrawal_record)
            
            # Step 9: Reserve user balance
            await self.reserve_user_balance(user_id, total_required)
            
            return {
                'withdrawal_id': withdrawal_id,
                'amount': amount,
                'fee': withdrawal_fee,
                'estimated_processing_time': '15-30 minutes',
                'approval_required': approval_required
            }
            
        except Exception as e:
            raise Exception(f"Withdrawal validation failed: {str(e)}")
    
    def is_valid_tari_address(self, address: str) -> bool:
        """Validate Tari address format"""
        base58_pattern = re.compile(r'^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$')
        return bool(base58_pattern.match(address)) and 50 <= len(address) <= 70
    
    def is_interactive_address(self, address: str) -> bool:
        """Check if address is interactive (not supported for withdrawals)"""
        try:
            decoded = base58.b58decode(address)
            if len(decoded) < 2:
                return False
            
            # Check the second byte (address type)
            // IMPORTANT: This logic must match official Tari address specification            # 0x01 = interactive, 0x00 = one-sided
            return (decoded[1] & 0x01) == 0x01
        except:
            return False
    
    def calculate_withdrawal_fee(self, amount: int) -> int:
        """Calculate withdrawal fee"""
        # Simple flat fee for now, could be percentage-based
        return self.WITHDRAWAL_FEE
    
    async def exceeds_withdrawal_limits(self, user_id: str, amount: int) -> bool:
        """Check if withdrawal exceeds daily/hourly limits"""
        daily_limit = 100_000_000_000  # 100,000 XTM
        hourly_limit = 10_000_000_000  # 10,000 XTM
        
        today_withdrawals = await self.get_today_withdrawals(user_id)
        hourly_withdrawals = await self.get_hourly_withdrawals(user_id)
        
        daily_total = sum(w['amount'] for w in today_withdrawals)
        hourly_total = sum(w['amount'] for w in hourly_withdrawals)
        
        return (daily_total + amount > daily_limit or 
                hourly_total + amount > hourly_limit)
    
    async def detect_suspicious_activity(self, user_id: str, amount: int, destination_address: str) -> bool:
        """Detect suspicious withdrawal patterns"""
        # Implement your fraud detection logic
        # Examples:
        # - Multiple withdrawals to same address
        # - Withdrawal immediately after deposit
        # - Unusual withdrawal patterns
        # - Address appears in fraud database
        
        return False  # Placeholder
    
    def generate_withdrawal_id(self) -> str:
        """Generate unique withdrawal ID"""
        import uuid
        return f"withdraw_{int(time.time())}_{uuid.uuid4().hex[:8]}"
    
    # Database helper methods (implement based on your database)
    async def get_user(self, user_id: str) -> Optional[Dict]:
        """Get user from database"""
        pass
    
    async def save_withdrawal(self, record: Dict):
        """Save withdrawal record in database"""
        pass
    
    async def reserve_user_balance(self, user_id: str, amount: int):
        """Reserve user balance for withdrawal"""
        pass
    
    async def get_today_withdrawals(self, user_id: str) -> List[Dict]:
        """Get user's withdrawals today"""
        pass
    
    async def get_hourly_withdrawals(self, user_id: str) -> List[Dict]:
        """Get user's withdrawals in last hour"""
        pass
    
    async def is_blacklisted_address(self, address: str) -> bool:
        """Check if address is blacklisted"""
        pass</code></pre>
            </div>
            
            <div id="withdraw-rust" class="tab-content">
                <pre><code>use chrono::{DateTime, Utc, Duration};
use regex::Regex;
use base58;
use uuid::Uuid;
use std::error::Error;

pub struct TariWithdrawalManager {
    min_withdrawal: u64,
    withdrawal_fee: u64,
    manual_approval_threshold: u64,
}

impl TariWithdrawalManager {
    pub fn new() -> Self {
        Self {
            min_withdrawal: 1_000_000,         // 1 XTM in microXTM
            withdrawal_fee: 25_000,            // 0.025 XTM
            manual_approval_threshold: 100_000_000_000, // 100,000 XTM
        }
    }
    
    pub async fn validate_withdrawal_request(
        &self,
        user_id: &str,
        destination_address: &str,
        amount: u64
    ) -> Result<WithdrawalDetails, Box<dyn Error>> {
        // Step 1: Validate user
        let user = self.get_user(user_id).await?
            .ok_or("User not found")?;
        
        if !user.is_kyc_verified {
            return Err("User not KYC verified".into());
        }
        
        if user.is_blocked || user.withdrawals_suspended {
            return Err("User account restricted".into());
        }
        
        // Step 2: Validate amount
        if amount == 0 || amount < self.min_withdrawal {
            return Err(format!("Amount below minimum withdrawal: {} XTM", 
                self.min_withdrawal as f64 / 1_000_000.0).into());
        }
        
        // Step 3: Check user balance
        let withdrawal_fee = self.calculate_withdrawal_fee(amount);
        let total_required = amount + withdrawal_fee;
        
        if user.available_balance < total_required {
            return Err(format!("Insufficient balance. Required: {} XTM, Available: {} XTM",
                total_required as f64 / 1_000_000.0,
                user.available_balance as f64 / 1_000_000.0).into());
        }
        
        // Step 4: Validate address
        if !self.is_valid_tari_address(destination_address) {
            return Err("Invalid Tari address format".into());
        }
        
        if self.is_interactive_address(destination_address)? {
            return Err("Interactive addresses not supported for withdrawals".into());
        }
        
        // Step 5: Security checks
        if self.is_blacklisted_address(destination_address).await? {
            return Err("Destination address is blacklisted".into());
        }
        
        // Step 6: Rate limiting
        if self.exceeds_withdrawal_limits(user_id, amount).await? {
            return Err("Withdrawal limits exceeded".into());
        }
        
        // Step 7: Detect suspicious activity
        if self.detect_suspicious_activity(user_id, amount, destination_address).await? {
            return Err("Withdrawal flagged for manual review".into());
        }
        
        // Step 8: Create withdrawal record
        let withdrawal_id = self.generate_withdrawal_id();
        let approval_required = amount > self.manual_approval_threshold;
        
        let withdrawal_record = WithdrawalRecord {
            id: withdrawal_id.clone(),
            user_id: user_id.to_string(),
            destination_address: destination_address.to_string(),
            amount,
            fee: withdrawal_fee,
            status: WithdrawalStatus::PendingApproval,
            created_at: Utc::now(),
            approval_required,
        };
        
        self.save_withdrawal(&withdrawal_record).await?;
        
        // Step 9: Reserve user balance
        self.reserve_user_balance(user_id, total_required).await?;
        
        Ok(WithdrawalDetails {
            withdrawal_id,
            amount,
            fee: withdrawal_fee,
            estimated_processing_time: "15-30 minutes".to_string(),
            approval_required,
        })
    }
    
    fn is_valid_tari_address(&self, address: &str) -> bool {
        let base58_regex = Regex::new(r"^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$")
            .unwrap();
        
        base58_regex.is_match(address) && address.len() >= 50 && address.len() <= 70
    }
    
    fn is_interactive_address(&self, address: &str) -> Result<bool, Box<dyn Error>> {
        let decoded = base58::decode(address)?;
        
        if decoded.len() < 2 {
            return Ok(false);
        }
        
        // Check the second byte (address type)
            // IMPORTANT: This logic must match official Tari address specification        // 0x01 = interactive, 0x00 = one-sided
        Ok((decoded[1] & 0x01) == 0x01)
    }
    
    fn calculate_withdrawal_fee(&self, _amount: u64) -> u64 {
        // Simple flat fee for now, could be percentage-based
        self.withdrawal_fee
    }
    
    async fn exceeds_withdrawal_limits(&self, user_id: &str, amount: u64) -> Result<bool, Box<dyn Error>> {
        let daily_limit = 100_000_000_000u64;  // 100,000 XTM
        let hourly_limit = 10_000_000_000u64;  // 10,000 XTM
        
        let today_withdrawals = self.get_today_withdrawals(user_id).await?;
        let hourly_withdrawals = self.get_hourly_withdrawals(user_id).await?;
        
        let daily_total: u64 = today_withdrawals.iter().map(|w| w.amount).sum();
        let hourly_total: u64 = hourly_withdrawals.iter().map(|w| w.amount).sum();
        
        Ok(daily_total + amount > daily_limit || hourly_total + amount > hourly_limit)
    }
    
    async fn detect_suspicious_activity(&self, _user_id: &str, _amount: u64, _destination_address: &str) -> Result<bool, Box<dyn Error>> {
        // Implement your fraud detection logic
        Ok(false) // Placeholder
    }
    
    fn generate_withdrawal_id(&self) -> String {
        format!("withdraw_{}_{}", 
            Utc::now().timestamp(),
            Uuid::new_v4().to_string()[..8].to_string()
        )
    }
    
    // Database helper methods (implement based on your database)
    async fn get_user(&self, user_id: &str) -> Result<Option<User>, Box<dyn Error>> {
        // Implementation
        Ok(None)
    }
    
    async fn save_withdrawal(&self, record: &WithdrawalRecord) -> Result<(), Box<dyn Error>> {
        // Implementation
        Ok(())
    }
    
    async fn reserve_user_balance(&self, user_id: &str, amount: u64) -> Result<(), Box<dyn Error>> {
        // Implementation
        Ok(())
    }
    
    async fn get_today_withdrawals(&self, user_id: &str) -> Result<Vec<WithdrawalRecord>, Box<dyn Error>> {
        // Implementation
        Ok(vec![])
    }
    
    async fn get_hourly_withdrawals(&self, user_id: &str) -> Result<Vec<WithdrawalRecord>, Box<dyn Error>> {
        // Implementation
        Ok(vec![])
    }
    
    async fn is_blacklisted_address(&self, address: &str) -> Result<bool, Box<dyn Error>> {
        // Implementation
        Ok(false)
    }
}

#[derive(Debug)]
struct User {
    id: String,
    available_balance: u64,
    is_kyc_verified: bool,
    is_blocked: bool,
    withdrawals_suspended: bool,
}

#[derive(Debug)]
struct WithdrawalRecord {
    id: String,
    user_id: String,
    destination_address: String,
    amount: u64,
    fee: u64,
    status: WithdrawalStatus,
    created_at: DateTime<Utc>,
    approval_required: bool,
}

#[derive(Debug)]
struct WithdrawalDetails {
    withdrawal_id: String,
    amount: u64,
    fee: u64,
    estimated_processing_time: String,
    approval_required: bool,
}

#[derive(Debug)]
enum WithdrawalStatus {
    PendingApproval,
    Approved,
    Processing,
    Completed,
    Failed,
    Cancelled,
}</code></pre>
            </div>
            
            <div id="withdraw-php" class="tab-content">
                <pre><code><?php

class TariWithdrawalManager {
    private const MIN_WITHDRAWAL = 1000000; // 1 XTM in microXTM
    private const WITHDRAWAL_FEE = 25000;   // 0.025 XTM
    private const MANUAL_APPROVAL_THRESHOLD = 100000000000; // 100,000 XTM
    
    public function validateWithdrawalRequest(string $userId, string $destinationAddress, int $amount): array {
        try {
            // Step 1: Validate user
            $user = $this->getUser($userId);
            if (!$user) {
                throw new Exception('User not found');
            }
            
            if (!$user['is_kyc_verified']) {
                throw new Exception('User not KYC verified');
            }
            
            if ($user['is_blocked'] || $user['withdrawals_suspended']) {
                throw new Exception('User account restricted');
            }
            
            // Step 2: Validate amount
            if ($amount <= 0 || $amount < self::MIN_WITHDRAWAL) {
                throw new Exception('Amount below minimum withdrawal: ' . (self::MIN_WITHDRAWAL / 1000000) . ' XTM');
            }
            
            // Step 3: Check user balance
            $withdrawalFee = $this->calculateWithdrawalFee($amount);
            $totalRequired = $amount + $withdrawalFee;
            
            if ($user['available_balance'] < $totalRequired) {
                throw new Exception(sprintf(
                    'Insufficient balance. Required: %.6f XTM, Available: %.6f XTM',
                    $totalRequired / 1000000,
                    $user['available_balance'] / 1000000
                ));
            }
            
            // Step 4: Validate address
            if (!$this->isValidTariAddress($destinationAddress)) {
                throw new Exception('Invalid Tari address format');
            }
            
            if ($this->isInteractiveAddress($destinationAddress)) {
                throw new Exception('Interactive addresses not supported for withdrawals');
            }
            
            // Step 5: Security checks
            if ($this->isBlacklistedAddress($destinationAddress)) {
                throw new Exception('Destination address is blacklisted');
            }
            
            // Step 6: Rate limiting
            if ($this->exceedsWithdrawalLimits($userId, $amount)) {
                throw new Exception('Withdrawal limits exceeded');
            }
            
            // Step 7: Detect suspicious activity
            if ($this->detectSuspiciousActivity($userId, $amount, $destinationAddress)) {
                throw new Exception('Withdrawal flagged for manual review');
            }
            
            // Step 8: Create withdrawal record
            $withdrawalId = $this->generateWithdrawalId();
            $approvalRequired = $amount > self::MANUAL_APPROVAL_THRESHOLD;
            
            $withdrawalRecord = [
                'id' => $withdrawalId,
                'user_id' => $userId,
                'destination_address' => $destinationAddress,
                'amount' => $amount,
                'fee' => $withdrawalFee,
                'status' => 'pending_approval',
                'created_at' => date('Y-m-d H:i:s'),
                'approval_required' => $approvalRequired
            ];
            
            $this->saveWithdrawal($withdrawalRecord);
            
            // Step 9: Reserve user balance
            $this->reserveUserBalance($userId, $totalRequired);
            
            return [
                'withdrawal_id' => $withdrawalId,
                'amount' => $amount,
                'fee' => $withdrawalFee,
                'estimated_processing_time' => '15-30 minutes',
                'approval_required' => $approvalRequired
            ];
            
        } catch (Exception $e) {
            throw new Exception("Withdrawal validation failed: " . $e->getMessage());
        }
    }
    
    private function isValidTariAddress(string $address): bool {
        $pattern = '/^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/';
        return preg_match($pattern, $address) && strlen($address) >= 50 && strlen($address) <= 70;
    }
    
    private function isInteractiveAddress(string $address): bool {
        try {
            $decoded = $this->base58Decode($address);
            if (strlen($decoded) < 2) {
                return false;
            }
            
            // Check the second byte (address type)
            // IMPORTANT: This logic must match official Tari address specification            // 0x01 = interactive, 0x00 = one-sided
            return (ord($decoded[1]) & 0x01) === 0x01;
        } catch (Exception $e) {
            return false;
        }
    }
    
    private function calculateWithdrawalFee(int $amount): int {
        // Simple flat fee for now, could be percentage-based
        return self::WITHDRAWAL_FEE;
    }
    
    private function exceedsWithdrawalLimits(string $userId, int $amount): bool {
        $dailyLimit = 100000000000;  // 100,000 XTM
        $hourlyLimit = 10000000000;  // 10,000 XTM
        
        $todayWithdrawals = $this->getTodayWithdrawals($userId);
        $hourlyWithdrawals = $this->getHourlyWithdrawals($userId);
        
        $dailyTotal = array_sum(array_column($todayWithdrawals, 'amount'));
        $hourlyTotal = array_sum(array_column($hourlyWithdrawals, 'amount'));
        
        return ($dailyTotal + $amount > $dailyLimit) || ($hourlyTotal + $amount > $hourlyLimit);
    }
    
    private function detectSuspiciousActivity(string $userId, int $amount, string $destinationAddress): bool {
        // Implement your fraud detection logic
        // Examples:
        // - Multiple withdrawals to same address
        // - Withdrawal immediately after deposit
        // - Unusual withdrawal patterns
        // - Address appears in fraud database
        
        return false; // Placeholder
    }
    
    private function generateWithdrawalId(): string {
        return 'withdraw_' . time() . '_' . bin2hex(random_bytes(4));
    }
    
    private function base58Decode(string $input): string {
        // Implementation of base58 decode
        // You might want to use a library like BitWasp\Bitcoin\Base58
        return $input; // Placeholder - implement proper Base58 decoding (e.g., BitWasp\Bitcoin\Base58)
    }
    
    // Database helper methods (implement based on your database)
    private function getUser(string $userId): ?array {
        // Implementation
        return null;
    }
    
    private function saveWithdrawal(array $record): void {
        // Implementation
    }
    
    private function reserveUserBalance(string $userId, int $amount): void {
        // Implementation
    }
    
    private function getTodayWithdrawals(string $userId): array {
        // Implementation
        return [];
    }
    
    private function getHourlyWithdrawals(string $userId): array {
        // Implementation
        return [];
    }
    
    private function isBlacklistedAddress(string $address): bool {
        // Implementation
        return false;
    }
}
?></code></pre>
            </div>
        </div>

        <h4><span class="step-number">2</span>Process Approved Withdrawals</h4>

        <div class="info">
            <strong>🔒 Cold Storage Operation:</strong> This step requires access to the cold storage wallet. Ensure proper security protocols are followed.
        </div>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'process-pseudocode')">Pseudocode</button>
                <button class="tab-button" onclick="switchTab(event, 'process-grpcurl')">grpcurl</button>
                <button class="tab-button" onclick="switchTab(event, 'process-nodejs')">Node.js</button>
                <button class="tab-button" onclick="switchTab(event, 'process-python')">Python</button>
                <button class="tab-button" onclick="switchTab(event, 'process-rust')">Rust</button>
                <button class="tab-button" onclick="switchTab(event, 'process-php')">PHP</button>
            </div>
            
            <div id="process-pseudocode" class="tab-content active">
                <div class="pseudocode-box">
                    <h4>🧠 Withdrawal Processing Logic</h4>
                    <pre><code>FUNCTION processApprovedWithdrawal(withdrawalRecord):
    // Step 1: Final validation checks
    IF (withdrawalRecord.status != "approved"):
        THROW "Withdrawal not approved for processing"
    
    IF (isWithdrawalExpired(withdrawalRecord)):
        markWithdrawalAsExpired(withdrawalRecord.id)
        THROW "Withdrawal request has expired"
    
    // Step 2: Connect to cold storage wallet
    TRY:
        coldWallet = connectToColdWallet()
        IF (NOT coldWallet.isOnline()):
            THROW "Cold wallet not accessible"
    CATCH (connection_error):
        THROW "Failed to connect to cold wallet: " + connection_error.message
    
    // Step 3: Sync wallet and verify balance
    TRY:
        coldWallet.sync()
        currentBalance = coldWallet.getBalance()
        
        totalRequired = withdrawalRecord.amount + withdrawalRecord.fee
        
        IF (currentBalance.available < totalRequired):
            notifyAdminsLowBalance(currentBalance.available, totalRequired)
            THROW "Insufficient cold wallet balance"
        
    CATCH (sync_error):
        THROW "Wallet sync failed: " + sync_error.message
    
    // Step 4: Create and validate payment recipient
    recipient = {
        address: withdrawalRecord.destinationAddress,
        amount: withdrawalRecord.amount,
        fee_per_gram: 25, // Standard fee rate
        payment_type: "ONE_SIDED", // Always use one-sided for exchanges
        payment_id: withdrawalRecord.id // Use withdrawal ID as payment ID
    }
    
    // Step 5: Final security checks
    IF (isAddressCompromised(recipient.address)):
        THROW "Destination address flagged as compromised"
    
    // Step 6: Execute the transaction
    TRY:
        // Update status to processing
        updateWithdrawalStatus(withdrawalRecord.id, "processing")
        
        // Send the transaction
        transactionRequest = {
            recipients: [recipient]
        }
        
        response = coldWallet.transfer(transactionRequest)
        
        // Step 7: Validate transaction response
        IF (response.results.length == 0):
            THROW "No transaction result received"
        
        result = response.results[0]
        
        IF (NOT result.is_success):
            THROW "Transaction failed: " + result.failure_message
        
        transactionId = result.transaction_id
        
        // Step 8: Get transaction details for verification
        transactionDetails = coldWallet.getTransactionInfo([transactionId])
        
        IF (transactionDetails.length == 0):
            THROW "Could not retrieve transaction details"
        
        txInfo = transactionDetails[0]
        
        // Step 9: Update database records
        BEGIN_DATABASE_TRANSACTION()
        
        updateWithdrawalStatus(withdrawalRecord.id, "completed")
        updateWithdrawalTransactionInfo(withdrawalRecord.id, {
            transactionId: transactionId,
            transactionHash: txInfo.excess_sig,
            broadcastTime: getCurrentTimestamp(),
            fee: txInfo.fee
        })
        
        // Deduct from user's reserved balance
        deductReservedBalance(withdrawalRecord.userId, totalRequired)
        
        // Create audit log entry
        createAuditLog({
            action: "withdrawal_processed",
            userId: withdrawalRecord.userId,
            amount: withdrawalRecord.amount,
            transactionId: transactionId,
            destinationAddress: withdrawalRecord.destinationAddress,
            processedBy: getCurrentOperator(),
            timestamp: getCurrentTimestamp()
        })
        
        COMMIT_DATABASE_TRANSACTION()
        
        // Step 10: Notifications
        notifyUserWithdrawalCompleted(withdrawalRecord.userId, {
            amount: withdrawalRecord.amount,
            transactionId: transactionId,
            estimatedConfirmationTime: "10-15 minutes"
        })
        
        // Step 11: Monitoring setup
        addTransactionToMonitoring(transactionId, withdrawalRecord.id)
        
        LOG "Successfully processed withdrawal: " + withdrawalRecord.id + 
            " for user " + withdrawalRecord.userId + 
            " amount " + (withdrawalRecord.amount / 1_000_000) + " XTM"
        
        RETURN {
            success: true,
            transactionId: transactionId,
            transactionHash: txInfo.excess_sig,
            estimatedConfirmationTime: "10-15 minutes"
        }
        
    CATCH (transaction_error):
        // Rollback database changes
        ROLLBACK_DATABASE_TRANSACTION()
        
        // Update withdrawal status to failed
        updateWithdrawalStatus(withdrawalRecord.id, "failed")
        addWithdrawalErrorLog(withdrawalRecord.id, transaction_error.message)
        
        // Notify admins of failure
        notifyAdminsWithdrawalFailed(withdrawalRecord, transaction_error.message)
        
        THROW "Transaction processing failed: " + transaction_error.message
    
    FINALLY:
        // Always disconnect from cold wallet for security
        IF (coldWallet):
            coldWallet.disconnect()</code></pre>
                </div>
            </div>
            
            <div id="process-grpcurl" class="tab-content">
                <div class="grpcurl-box">
                    <h4>🧪 Process Withdrawal with grpcurl</h4>
                    <pre><code># Complete withdrawal processing script
#!/bin/bash

echo "=== Cold Storage Withdrawal Processing ==="

# Configuration
WALLET_HOST="localhost:18143"
RECIPIENT_ADDRESS="${1:-}"
AMOUNT="${2:-1000000}"
WITHDRAWAL_ID="${3:-withdraw_$(date +%s)_$(openssl rand -hex 4)}"

if [ -z "$RECIPIENT_ADDRESS" ]; then
    echo "Usage: $0 <recipient_address> [amount_microxtm] [withdrawal_id]"
    echo "Example: $0 12HVCEeZC2RGE4SDn3yGwqz... 1000000 withdraw_123_abc"
    exit 1
fi

# Authentication (if enabled)
AUTH_HEADER=""
if [ -n "$WALLET_USER" ] && [ -n "$WALLET_PASS" ]; then
    AUTH_HEADER="-H authorization: Basic $(echo -n "$WALLET_USER:$WALLET_PASS" | base64 -w 0)"
fi

echo "🔐 Step 1: Connecting to cold wallet..."

# Test connectivity
if ! grpcurl -plaintext -connect-timeout 5 $AUTH_HEADER $WALLET_HOST list > /dev/null 2>&1; then
    echo "❌ Cold wallet not accessible"
    exit 1
fi

echo "✅ Cold wallet accessible"

echo "🔄 Step 2: Syncing wallet..."

# Get wallet state (this triggers sync)
WALLET_STATE=$(grpcurl -plaintext $AUTH_HEADER $WALLET_HOST tari.rpc.Wallet/GetState 2>/dev/null)

if [ $? -ne 0 ]; then
    echo "❌ Failed to get wallet state"
    exit 1
fi

# Extract sync status
SCANNED_HEIGHT=$(echo "$WALLET_STATE" | jq -r '.scanned_height // 0')
NETWORK_STATUS=$(echo "$WALLET_STATE" | jq -r '.network.status // "Unknown"')

echo "Wallet scanned height: $SCANNED_HEIGHT"
echo "Network status: $NETWORK_STATUS"

if [ "$NETWORK_STATUS" != "Online" ]; then
    echo "⚠️  Warning: Wallet not fully online"
fi

echo "💰 Step 3: Checking wallet balance..."

# Get current balance
BALANCE_RESPONSE=$(grpcurl -plaintext $AUTH_HEADER $WALLET_HOST tari.rpc.Wallet/GetBalance 2>/dev/null)
AVAILABLE_BALANCE=$(echo "$BALANCE_RESPONSE" | jq -r '.available_balance // 0')

echo "Available balance: $AVAILABLE_BALANCE microXTM"

# Calculate total required (amount + estimated fee)
FEE_PER_GRAM=25
ESTIMATED_FEE=$((FEE_PER_GRAM * 200))  # Rough estimate
TOTAL_REQUIRED=$((AMOUNT + ESTIMATED_FEE))

echo "Amount to send: $AMOUNT microXTM"
echo "Estimated fee: $ESTIMATED_FEE microXTM"
echo "Total required: $TOTAL_REQUIRED microXTM"

if [ "$AVAILABLE_BALANCE" -lt "$TOTAL_REQUIRED" ]; then
    echo "❌ Insufficient balance"
    echo "Available: $(echo "scale=6; $AVAILABLE_BALANCE / 1000000" | bc) XTM"
    echo "Required: $(echo "scale=6; $TOTAL_REQUIRED / 1000000" | bc) XTM"
    exit 1
fi

echo "✅ Sufficient balance"

echo "🚀 Step 4: Processing withdrawal..."

# Encode withdrawal ID as payment ID
PAYMENT_ID_B64=$(echo -n "$WITHDRAWAL_ID" | base64 -w 0)

# Execute withdrawal
WITHDRAW_RESPONSE=$(grpcurl -plaintext $AUTH_HEADER \
  -d "{
    \"recipients\": [{
      \"address\": \"$RECIPIENT_ADDRESS\",
      \"amount\": $AMOUNT,
      \"fee_per_gram\": $FEE_PER_GRAM,
      \"payment_type\": \"ONE_SIDED\",
      \"payment_id\": \"$PAYMENT_ID_B64\"
    }]
  }" \
  $WALLET_HOST \
  tari.rpc.Wallet/Transfer 2>/dev/null)

if [ $? -ne 0 ]; then
    echo "❌ Withdrawal transaction failed"
    exit 1
fi

echo "✅ Withdrawal transaction sent"

# Parse response
IS_SUCCESS=$(echo "$WITHDRAW_RESPONSE" | jq -r '.results[0].is_success // false')
TRANSACTION_ID=$(echo "$WITHDRAW_RESPONSE" | jq -r '.results[0].transaction_id // empty')
FAILURE_MESSAGE=$(echo "$WITHDRAW_RESPONSE" | jq -r '.results[0].failure_message // empty')

if [ "$IS_SUCCESS" != "true" ]; then
    echo "❌ Transaction failed: $FAILURE_MESSAGE"
    exit 1
fi

echo "📋 Transaction ID: $TRANSACTION_ID"

echo "🔍 Step 5: Getting transaction details..."

# Get detailed transaction information
TX_INFO=$(grpcurl -plaintext $AUTH_HEADER \
  -d "{\"transaction_ids\": [$TRANSACTION_ID]}" \
  $WALLET_HOST \
  tari.rpc.Wallet/GetTransactionInfo 2>/dev/null)

if [ $? -eq 0 ] && [ -n "$TX_INFO" ]; then
    echo "Transaction details:"
    echo "$TX_INFO" | jq .
    
    # Extract transaction hash
    TX_HASH=$(echo "$TX_INFO" | jq -r '.transactions[0].excess_sig // empty')
    if [ -n "$TX_HASH" ]; then
        echo "📄 Transaction Hash: $TX_HASH"
    fi
else
    echo "⚠️  Could not retrieve transaction details"
fi

echo "✅ Withdrawal processing complete"

# Summary
echo "==================="
echo "WITHDRAWAL SUMMARY"
echo "==================="
echo "Withdrawal ID: $WITHDRAWAL_ID"
echo "Recipient: $RECIPIENT_ADDRESS"
echo "Amount: $(echo "scale=6; $AMOUNT / 1000000" | bc) XTM"
echo "Transaction ID: $TRANSACTION_ID"
echo "Status: Completed"
echo "Estimated confirmation: 10-15 minutes"
echo "==================="

# Optional: Monitor transaction status
echo "💡 To monitor transaction status:"
echo "grpcurl -plaintext $AUTH_HEADER -d '{\"transaction_ids\": [$TRANSACTION_ID]}' $WALLET_HOST tari.rpc.Wallet/GetTransactionInfo"</code></pre>
                </div>
            </div>
            
            <div id="process-nodejs" class="tab-content">
                <pre><code>class TariWithdrawalProcessor {
    constructor(walletClient, metadata) {
        this.walletClient = walletClient;
        this.metadata = metadata;
    }
    
    async processApprovedWithdrawal(withdrawalRecord) {
        let transactionResult = null;
        
        try {
            // Step 1: Final validation
            if (withdrawalRecord.status !== 'approved') {
                throw new Error('Withdrawal not approved for processing');
            }
            
            if (this.isWithdrawalExpired(withdrawalRecord)) {
                await this.markWithdrawalAsExpired(withdrawalRecord.id);
                throw new Error('Withdrawal request has expired');
            }
            
            // Step 2: Sync wallet and check balance
            console.log('🔄 Syncing cold wallet...');
            await this.syncWallet();
            
            const balance = await this.getWalletBalance();
            const totalRequired = withdrawalRecord.amount + withdrawalRecord.fee;
            
            if (balance.available_balance < totalRequired) {
                await this.notifyAdminsLowBalance(balance.available_balance, totalRequired);
                throw new Error(`Insufficient cold wallet balance: ${balance.available_balance / 1000000} XTM available, ${totalRequired / 1000000} XTM required`);
            }
            
            console.log(`✅ Sufficient balance: ${balance.available_balance / 1000000} XTM`);
            
            // Step 3: Create payment recipient
            const recipient = {
                address: withdrawalRecord.destinationAddress,
                amount: withdrawalRecord.amount,
                fee_per_gram: 25,
                payment_type: 'ONE_SIDED',
                payment_id: Buffer.from(withdrawalRecord.id, 'utf8')
            };
            
            // Step 4: Final security checks
            if (await this.isAddressCompromised(recipient.address)) {
                throw new Error('Destination address flagged as compromised');
            }
            
            // Step 5: Update status to processing
            await this.updateWithdrawalStatus(withdrawalRecord.id, 'processing');
            
            // Step 6: Execute transaction
            console.log('🚀 Executing withdrawal transaction...');
            
            const response = await new Promise((resolve, reject) => {
                this.walletClient.Transfer(
                    { recipients: [recipient] },
                    this.metadata,
                    (error, response) => {
                        if (error) reject(error);
                        else resolve(response);
                    }
                );
            });
            
            // Step 7: Validate transaction response
            if (!response.results || response.results.length === 0) {
                throw new Error('No transaction result received');
            }
            
            const result = response.results[0];
            
            if (!result.is_success) {
                throw new Error(`Transaction failed: ${result.failure_message}`);
            }
            
            const transactionId = result.transaction_id;
            console.log(`✅ Transaction sent successfully. ID: ${transactionId}`);
            
            // Step 8: Get transaction details for verification
            const transactionDetails = await this.getTransactionDetails(transactionId);
            
            transactionResult = {
                transactionId: transactionId,
                transactionHash: transactionDetails.excess_sig ? 
                    Buffer.from(transactionDetails.excess_sig).toString('hex') : null,
                fee: transactionDetails.fee,
                broadcastTime: new Date()
            };
            
            // Step 9: Update database records (atomic transaction)
            await this.updateWithdrawalCompletion(withdrawalRecord, transactionResult);
            
            // Step 10: Notifications
            await this.notifyUserWithdrawalCompleted(withdrawalRecord.userId, {
                amount: withdrawalRecord.amount,
                transactionId: transactionId,
                estimatedConfirmationTime: '10-15 minutes'
            });
            
            // Step 11: Setup monitoring
            await this.addTransactionToMonitoring(transactionId, withdrawalRecord.id);
            
            console.log(`✅ Successfully processed withdrawal ${withdrawalRecord.id} for user ${withdrawalRecord.userId}`);
            
            return {
                success: true,
                transactionId: transactionId,
                transactionHash: transactionResult.transactionHash,
                estimatedConfirmationTime: '10-15 minutes'
            };
            
        } catch (error) {
            console.error(`❌ Withdrawal processing failed: ${error.message}`);
            
            // Update withdrawal status to failed
            await this.updateWithdrawalStatus(withdrawalRecord.id, 'failed');
            await this.addWithdrawalErrorLog(withdrawalRecord.id, error.message);
            
            // Notify admins
            await this.notifyAdminsWithdrawalFailed(withdrawalRecord, error.message);
            
            throw error;
        }
    }
    
    async syncWallet() {
        return new Promise((resolve, reject) => {
            this.walletClient.GetState({}, this.metadata, (error, response) => {
                if (error) reject(error);
                else resolve(response);
            });
        });
    }
    
    async getWalletBalance() {
        return new Promise((resolve, reject) => {
            this.walletClient.GetBalance({}, this.metadata, (error, response) => {
                if (error) reject(error);
                else resolve(response);
            });
        });
    }
    
    async getTransactionDetails(transactionId) {
        return new Promise((resolve, reject) => {
            this.walletClient.GetTransactionInfo(
                { transaction_ids: [transactionId] },
                this.metadata,
                (error, response) => {
                    if (error) reject(error);
                    else {
                        const tx = response.transactions[0];
                        resolve(tx || {});
                    }
                }
            );
        });
    }
    
    async updateWithdrawalCompletion(withdrawalRecord, transactionResult) {
        // Implement atomic database transaction
        try {
            // Start database transaction
            await this.database.beginTransaction();
            
            // Update withdrawal status
            await this.updateWithdrawalStatus(withdrawalRecord.id, 'completed');
            
            // Update transaction info
            await this.updateWithdrawalTransactionInfo(withdrawalRecord.id, transactionResult);
            
            // Deduct from user's reserved balance
            await this.deductReservedBalance(
                withdrawalRecord.userId, 
                withdrawalRecord.amount + withdrawalRecord.fee
            );
            
            // Create audit log
            await this.createAuditLog({
                action: 'withdrawal_processed',
                userId: withdrawalRecord.userId,
                amount: withdrawalRecord.amount,
                transactionId: transactionResult.transactionId,
                destinationAddress: withdrawalRecord.destinationAddress,
                processedBy: this.getCurrentOperator(),
                timestamp: new Date()
            });
            
            // Commit transaction
            await this.database.commitTransaction();
            
        } catch (error) {
            await this.database.rollbackTransaction();
            throw error;
        }
    }
    
    isWithdrawalExpired(withdrawalRecord) {
        const expirationTime = 24 * 60 * 60 * 1000; // 24 hours
        return Date.now() - withdrawalRecord.createdAt.getTime() > expirationTime;
    }
    
    // Helper methods (implement based on your system)
    async updateWithdrawalStatus(withdrawalId, status) { /* Implementation */ }
    async markWithdrawalAsExpired(withdrawalId) { /* Implementation */ }
    async isAddressCompromised(address) { /* Implementation */ }
    async notifyAdminsLowBalance(available, required) { /* Implementation */ }
    async notifyUserWithdrawalCompleted(userId, details) { /* Implementation */ }
    async notifyAdminsWithdrawalFailed(withdrawal, error) { /* Implementation */ }
    async addTransactionToMonitoring(txId, withdrawalId) { /* Implementation */ }
    async addWithdrawalErrorLog(withdrawalId, error) { /* Implementation */ }
    async updateWithdrawalTransactionInfo(withdrawalId, txInfo) { /* Implementation */ }
    async deductReservedBalance(userId, amount) { /* Implementation */ }
    async createAuditLog(logEntry) { /* Implementation */ }
    getCurrentOperator() { return 'system'; }
}</code></pre>
            </div>
            
            <div id="process-python" class="tab-content">
                <pre><code>import asyncio
from datetime import datetime, timedelta
from typing import Dict, Optional

class TariWithdrawalProcessor:
    def __init__(self, wallet_client, metadata):
        self.wallet_client = wallet_client
        self.metadata = metadata
    
    async def process_approved_withdrawal(self, withdrawal_record: Dict) -> Dict:
        """Process an approved withdrawal through the cold storage wallet"""
        transaction_result = None
        
        try:
            # Step 1: Final validation
            if withdrawal_record['status'] != 'approved':
                raise Exception('Withdrawal not approved for processing')
            
            if self.is_withdrawal_expired(withdrawal_record):
                await self.mark_withdrawal_as_expired(withdrawal_record['id'])
                raise Exception('Withdrawal request has expired')
            
            # Step 2: Sync wallet and check balance
            print('🔄 Syncing cold wallet...')
            await self.sync_wallet()
            
            balance = await self.get_wallet_balance()
            total_required = withdrawal_record['amount'] + withdrawal_record['fee']
            
            if balance.available_balance < total_required:
                await self.notify_admins_low_balance(balance.available_balance, total_required)
                raise Exception(f'Insufficient cold wallet balance: {balance.available_balance / 1_000_000} XTM available, {total_required / 1_000_000} XTM required')
            
            print(f'✅ Sufficient balance: {balance.available_balance / 1_000_000} XTM')
            
            # Step 3: Create payment recipient
            recipient = wallet_pb2.PaymentRecipient(
                address=withdrawal_record['destination_address'],
                amount=withdrawal_record['amount'],
                fee_per_gram=25,
                payment_type=wallet_pb2.PaymentRecipient.PaymentType.ONE_SIDED,
                payment_id=withdrawal_record['id'].encode('utf-8')
            )
            
            # Step 4: Final security checks
            if await self.is_address_compromised(recipient.address):
                raise Exception('Destination address flagged as compromised')
            
            # Step 5: Update status to processing
            await self.update_withdrawal_status(withdrawal_record['id'], 'processing')
            
            # Step 6: Execute transaction
            print('🚀 Executing withdrawal transaction...')
            
            request = wallet_pb2.TransferRequest(recipients=[recipient])
            response = self.wallet_client.Transfer(request, metadata=self.metadata)
            
            # Step 7: Validate transaction response
            if not response.results or len(response.results) == 0:
                raise Exception('No transaction result received')
            
            result = response.results[0]
            
            if not result.is_success:
                raise Exception(f'Transaction failed: {result.failure_message}')
            
            transaction_id = result.transaction_id
            print(f'✅ Transaction sent successfully. ID: {transaction_id}')
            
            # Step 8: Get transaction details for verification
            transaction_details = await self.get_transaction_details(transaction_id)
            
            transaction_result = {
                'transaction_id': transaction_id,
                'transaction_hash': transaction_details.excess_sig.hex() if transaction_details.excess_sig else None,
                'fee': transaction_details.fee,
                'broadcast_time': datetime.now()
            }
            
            # Step 9: Update database records (atomic transaction)
            await self.update_withdrawal_completion(withdrawal_record, transaction_result)
            
            # Step 10: Notifications
            await self.notify_user_withdrawal_completed(withdrawal_record['user_id'], {
                'amount': withdrawal_record['amount'],
                'transaction_id': transaction_id,
                'estimated_confirmation_time': '10-15 minutes'
            })
            
            # Step 11: Setup monitoring
            await self.add_transaction_to_monitoring(transaction_id, withdrawal_record['id'])
            
            print(f'✅ Successfully processed withdrawal {withdrawal_record["id"]} for user {withdrawal_record["user_id"]}')
            
            return {
                'success': True,
                'transaction_id': transaction_id,
                'transaction_hash': transaction_result['transaction_hash'],
                'estimated_confirmation_time': '10-15 minutes'
            }
            
        except Exception as error:
            print(f'❌ Withdrawal processing failed: {error}')
            
            # Update withdrawal status to failed
            await self.update_withdrawal_status(withdrawal_record['id'], 'failed')
            await self.add_withdrawal_error_log(withdrawal_record['id'], str(error))
            
            # Notify admins
            await self.notify_admins_withdrawal_failed(withdrawal_record, str(error))
            
            raise error
    
    async def sync_wallet(self):
        """Sync wallet with blockchain"""
        request = wallet_pb2.GetStateRequest()
        response = self.wallet_client.GetState(request, metadata=self.metadata)
        return response
    
    async def get_wallet_balance(self):
        """Get current wallet balance"""
        request = wallet_pb2.GetBalanceRequest()
        response = self.wallet_client.GetBalance(request, metadata=self.metadata)
        return response
    
    async def get_transaction_details(self, transaction_id: int):
        """Get detailed transaction information"""
        request = wallet_pb2.GetTransactionInfoRequest(transaction_ids=[transaction_id])
        response = self.wallet_client.GetTransactionInfo(request, metadata=self.metadata)
        
        if response.transactions:
            return response.transactions[0]
        return None
    
    async def update_withdrawal_completion(self, withdrawal_record: Dict, transaction_result: Dict):
        """Update withdrawal completion with atomic database transaction"""
        try:
            # Start database transaction
            await self.database.begin_transaction()
            
            # Update withdrawal status
            await self.update_withdrawal_status(withdrawal_record['id'], 'completed')
            
            # Update transaction info
            await self.update_withdrawal_transaction_info(withdrawal_record['id'], transaction_result)
            
            # Deduct from user's reserved balance
            await self.deduct_reserved_balance(
                withdrawal_record['user_id'],
                withdrawal_record['amount'] + withdrawal_record['fee']
            )
            
            # Create audit log
            await self.create_audit_log({
                'action': 'withdrawal_processed',
                'user_id': withdrawal_record['user_id'],
                'amount': withdrawal_record['amount'],
                'transaction_id': transaction_result['transaction_id'],
                'destination_address': withdrawal_record['destination_address'],
                'processed_by': self.get_current_operator(),
                'timestamp': datetime.now()
            })
            
            # Commit transaction
            await self.database.commit_transaction()
            
        except Exception as error:
            await self.database.rollback_transaction()
            raise error
    
    def is_withdrawal_expired(self, withdrawal_record: Dict) -> bool:
        """Check if withdrawal request has expired"""
        expiration_time = timedelta(hours=24)
        return datetime.now() - withdrawal_record['created_at'] > expiration_time
    
    # Helper methods (implement based on your system)
    async def update_withdrawal_status(self, withdrawal_id: str, status: str):
        """Update withdrawal status"""
        pass
    
    async def mark_withdrawal_as_expired(self, withdrawal_id: str):
        """Mark withdrawal as expired"""
        pass
    
    async def is_address_compromised(self, address: str) -> bool:
        """Check if address is compromised"""
        return False
    
    async def notify_admins_low_balance(self, available: int, required: int):
        """Notify admins of low balance"""
        pass
    
    async def notify_user_withdrawal_completed(self, user_id: str, details: Dict):
        """Notify user of completed withdrawal"""
        pass
    
    async def notify_admins_withdrawal_failed(self, withdrawal: Dict, error: str):
        """Notify admins of failed withdrawal"""
        pass
    
    async def add_transaction_to_monitoring(self, tx_id: int, withdrawal_id: str):
        """Add transaction to monitoring system"""
        pass
    
    async def add_withdrawal_error_log(self, withdrawal_id: str, error: str):
        """Log withdrawal error"""
        pass
    
    async def update_withdrawal_transaction_info(self, withdrawal_id: str, tx_info: Dict):
        """Update withdrawal with transaction info"""
        pass
    
    async def deduct_reserved_balance(self, user_id: str, amount: int):
        """Deduct amount from user's reserved balance"""
        pass
    
    async def create_audit_log(self, log_entry: Dict):
        """Create audit log entry"""
        pass
    
    def get_current_operator(self) -> str:
        """Get current system operator"""
        return 'system'</code></pre>
            </div>
            
            <div id="process-rust" class="tab-content">
                <pre><code>use tokio::time::{sleep, Duration};
use chrono::{DateTime, Utc};
use std::error::Error;

pub struct TariWithdrawalProcessor {
    wallet_client: WalletClient<Channel>,
    metadata: MetadataMap,
}

impl TariWithdrawalProcessor {
    pub fn new(wallet_client: WalletClient<Channel>, metadata: MetadataMap) -> Self {
        Self {
            wallet_client,
            metadata,
        }
    }
    
    pub async fn process_approved_withdrawal(&mut self, withdrawal_record: &WithdrawalRecord) -> Result<WithdrawalResult, Box<dyn Error>> {
        // Step 1: Final validation
        if withdrawal_record.status != WithdrawalStatus::Approved {
            return Err("Withdrawal not approved for processing".into());
        }
        
        if self.is_withdrawal_expired(withdrawal_record) {
            self.mark_withdrawal_as_expired(&withdrawal_record.id).await?;
            return Err("Withdrawal request has expired".into());
        }
        
        // Step 2: Sync wallet and check balance
        println!("🔄 Syncing cold wallet...");
        self.sync_wallet().await?;
        
        let balance = self.get_wallet_balance().await?;
        let total_required = withdrawal_record.amount + withdrawal_record.fee;
        
        if balance.available_balance < total_required {
            self.notify_admins_low_balance(balance.available_balance, total_required).await?;
            return Err(format!("Insufficient cold wallet balance: {} XTM available, {} XTM required",
                balance.available_balance as f64 / 1_000_000.0,
                total_required as f64 / 1_000_000.0).into());
        }
        
        println!("✅ Sufficient balance: {} XTM", balance.available_balance as f64 / 1_000_000.0);
        
        // Step 3: Create payment recipient
        let recipient = PaymentRecipient {
            address: withdrawal_record.destination_address.clone(),
            amount: withdrawal_record.amount,
            fee_per_gram: 25,
            payment_type: PaymentType::OneSided as i32,
            payment_id: withdrawal_record.id.as_bytes().to_vec(),
        };
        
        // Step 4: Final security checks
        if self.is_address_compromised(&recipient.address).await? {
            return Err("Destination address flagged as compromised".into());
        }
        
        // Step 5: Update status to processing
        self.update_withdrawal_status(&withdrawal_record.id, WithdrawalStatus::Processing).await?;
        
        // Step 6: Execute transaction
        println!("🚀 Executing withdrawal transaction...");
        
        let mut request = Request::new(TransferRequest {
            recipients: vec![recipient],
        });
        
        // Add authentication metadata
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        
        // Add authentication metadata
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        
        // Add authentication metadata
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        // Add authentication metadata
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }

        // Add authentication metadata
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }

        let response = self.wallet_client.transfer(request).await?;
        let response = response.into_inner();
        
        // Step 7: Validate transaction response
        let result = response.results.first()
            .ok_or("No transaction result received")?;
        
        if !result.is_success {
            let error_msg = format!("Transaction failed: {}", result.failure_message);
            self.update_withdrawal_status(&withdrawal_record.id, WithdrawalStatus::Failed).await?;
            self.add_withdrawal_error_log(&withdrawal_record.id, &error_msg).await?;
            return Err(error_msg.into());
        }
        
        let transaction_id = result.transaction_id;
        println!("✅ Transaction sent successfully. ID: {}", transaction_id);
        
        // Step 8: Get transaction details for verification
        let transaction_details = self.get_transaction_details(transaction_id).await?;
        
        let transaction_result = TransactionResult {
            transaction_id,
            transaction_hash: if !transaction_details.excess_sig.is_empty() {
                Some(hex::encode(&transaction_details.excess_sig))
            } else {
                None
            },
            fee: transaction_details.fee,
            broadcast_time: Utc::now(),
        };
        
        // Step 9: Update database records (atomic transaction)
        self.update_withdrawal_completion(withdrawal_record, &transaction_result).await?;
        
        // Step 10: Notifications
        self.notify_user_withdrawal_completed(&withdrawal_record.user_id, &WithdrawalNotification {
            amount: withdrawal_record.amount,
            transaction_id,
            estimated_confirmation_time: "10-15 minutes".to_string(),
        }).await?;
        
        // Step 11: Setup monitoring
        self.add_transaction_to_monitoring(transaction_id, &withdrawal_record.id).await?;
        
        println!("✅ Successfully processed withdrawal {} for user {}", 
            withdrawal_record.id, withdrawal_record.user_id);
        
        Ok(WithdrawalResult {
            success: true,
            transaction_id,
            transaction_hash: transaction_result.transaction_hash,
            estimated_confirmation_time: "10-15 minutes".to_string(),
        })
    }
    
    async fn sync_wallet(&mut self) -> Result<(), Box<dyn Error>> {
        let mut request = Request::new(());
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }

        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }

        let _response = self.wallet_client.get_state(request).await?;
        Ok(())
    }
    
    async fn get_wallet_balance(&mut self) -> Result<GetBalanceResponse, Box<dyn Error>> {
        let mut request = Request::new(GetBalanceRequest::default());
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }

        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }

        let response = self.wallet_client.get_balance(request).await?;
        Ok(response.into_inner())
    }
    
    async fn get_transaction_details(&mut self, transaction_id: u64) -> Result<TransactionInfo, Box<dyn Error>> {
        let mut request = Request::new(GetTransactionInfoRequest {
            transaction_ids: vec![transaction_id],
        });
        
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        for (key, value) in &self.metadata {
            request.metadata_mut().insert(key.clone(), value.clone());
        }
        let response = self.wallet_client.get_transaction_info(request).await?;
        let response = response.into_inner();
        
        response.transactions.first()
            .cloned()
            .ok_or("Transaction not found".into())
    }
    
    async fn update_withdrawal_completion(&self, withdrawal_record: &WithdrawalRecord, transaction_result: &TransactionResult) -> Result<(), Box<dyn Error>> {
        // Implement atomic database transaction
        // 1. Start database transaction
        // 2. Update withdrawal status
        // 3. Update transaction info
        // 4. Deduct from user's reserved balance
        // 5. Create audit log
        // 6. Commit transaction
        
        println!("Updating withdrawal completion for {}", withdrawal_record.id);
        Ok(())
    }
    
    fn is_withdrawal_expired(&self, withdrawal_record: &WithdrawalRecord) -> bool {
        let expiration_duration = chrono::Duration::hours(24);
        Utc::now() - withdrawal_record.created_at > expiration_duration
    }
    
    // Helper methods (implement based on your system)
    async fn update_withdrawal_status(&self, withdrawal_id: &str, status: WithdrawalStatus) -> Result<(), Box<dyn Error>> {
        println!("Updating withdrawal {} status to {:?}", withdrawal_id, status);
        Ok(())
    }
    
    async fn mark_withdrawal_as_expired(&self, withdrawal_id: &str) -> Result<(), Box<dyn Error>> {
        println!("Marking withdrawal {} as expired", withdrawal_id);
        Ok(())
    }
    
    async fn is_address_compromised(&self, address: &str) -> Result<bool, Box<dyn Error>> {
        // Check against blacklist/compromised address database
        Ok(false)
    }
    
    async fn notify_admins_low_balance(&self, available: u64, required: u64) -> Result<(), Box<dyn Error>> {
        println!("⚠️  Low balance alert: {} available, {} required", available, required);
        Ok(())
    }
    
    async fn notify_user_withdrawal_completed(&self, user_id: &str, notification: &WithdrawalNotification) -> Result<(), Box<dyn Error>> {
        println!("Notifying user {} of completed withdrawal", user_id);
        Ok(())
    }
    
    async fn add_transaction_to_monitoring(&self, tx_id: u64, withdrawal_id: &str) -> Result<(), Box<dyn Error>> {
        println!("Adding transaction {} to monitoring for withdrawal {}", tx_id, withdrawal_id);
        Ok(())
    }
    
    async fn add_withdrawal_error_log(&self, withdrawal_id: &str, error: &str) -> Result<(), Box<dyn Error>> {
        println!("Error log for withdrawal {}: {}", withdrawal_id, error);
        Ok(())
    }
}

#[derive(Debug)]
struct TransactionResult {
    transaction_id: u64,
    transaction_hash: Option<String>,
    fee: u64,
    broadcast_time: DateTime<Utc>,
}

#[derive(Debug)]
struct WithdrawalNotification {
    amount: u64,
    transaction_id: u64,
    estimated_confirmation_time: String,
}

#[derive(Debug)]
pub struct WithdrawalResult {
    pub success: bool,
    pub transaction_id: u64,
    pub transaction_hash: Option<String>,
    pub estimated_confirmation_time: String,
}</code></pre>
            </div>
            
            <div id="process-php" class="tab-content">
                <pre><code><?php

class TariWithdrawalProcessor {
    private $walletClient;
    private $metadata;
    
    public function __construct($walletClient, $metadata) {
        $this->walletClient = $walletClient;
        $this->metadata = $metadata;
    }
    
    public function processApprovedWithdrawal(array $withdrawalRecord): array {
        $transactionResult = null;
        
        try {
            // Step 1: Final validation
            if ($withdrawalRecord['status'] !== 'approved') {
                throw new Exception('Withdrawal not approved for processing');
            }
            
            if ($this->isWithdrawalExpired($withdrawalRecord)) {
                $this->markWithdrawalAsExpired($withdrawalRecord['id']);
                throw new Exception('Withdrawal request has expired');
            }
            
            // Step 2: Sync wallet and check balance
            echo "🔄 Syncing cold wallet...\n";
            $this->syncWallet();
            
            $balance = $this->getWalletBalance();
            $totalRequired = $withdrawalRecord['amount'] + $withdrawalRecord['fee'];
            
            if ($balance->getAvailableBalance() < $totalRequired) {
                $this->notifyAdminsLowBalance($balance->getAvailableBalance(), $totalRequired);
                throw new Exception(sprintf(
                    'Insufficient cold wallet balance: %.6f XTM available, %.6f XTM required',
                    $balance->getAvailableBalance() / 1000000,
                    $totalRequired / 1000000
                ));
            }
            
            echo sprintf("✅ Sufficient balance: %.6f XTM\n", $balance->getAvailableBalance() / 1000000);
            
            // Step 3: Create payment recipient
            $recipient = new \Tari\Rpc\PaymentRecipient([
                'address' => $withdrawalRecord['destination_address'],
                'amount' => $withdrawalRecord['amount'],
                'fee_per_gram' => 25,
                'payment_type' => \Tari\Rpc\PaymentRecipient\PaymentType::ONE_SIDED,
                'payment_id' => $withdrawalRecord['id']
            ]);
            
            // Step 4: Final security checks
            if ($this->isAddressCompromised($recipient->getAddress())) {
                throw new Exception('Destination address flagged as compromised');
            }
            
            // Step 5: Update status to processing
            $this->updateWithdrawalStatus($withdrawalRecord['id'], 'processing');
            
            // Step 6: Execute transaction
            echo "🚀 Executing withdrawal transaction...\n";
            
            $request = new \Tari\Rpc\TransferRequest([
                'recipients' => [$recipient]
            ]);
            
            list($response, $status) = $this->walletClient->Transfer(
                $request,
                $this->metadata
            )->wait();
            
            if ($status->code !== Grpc\STATUS_OK) {
                throw new Exception("gRPC error: " . $status->details);
            }
            
            // Step 7: Validate transaction response
            $results = $response->getResults();
            if (empty($results)) {
                throw new Exception('No transaction result received');
            }
            
            $result = $results[0];
            
            if (!$result->getIsSuccess()) {
                throw new Exception("Transaction failed: " . $result->getFailureMessage());
            }
            
            $transactionId = $result->getTransactionId();
            echo "✅ Transaction sent successfully. ID: {$transactionId}\n";
            
            // Step 8: Get transaction details for verification
            $transactionDetails = $this->getTransactionDetails($transactionId);
            
            $transactionResult = [
                'transaction_id' => $transactionId,
                'transaction_hash' => $transactionDetails ? bin2hex($transactionDetails->getExcessSig()) : null,
                'fee' => $transactionDetails ? $transactionDetails->getFee() : 0,
                'broadcast_time' => date('Y-m-d H:i:s')
            ];
            
            // Step 9: Update database records (atomic transaction)
            $this->updateWithdrawalCompletion($withdrawalRecord, $transactionResult);
            
            // Step 10: Notifications
            $this->notifyUserWithdrawalCompleted($withdrawalRecord['user_id'], [
                'amount' => $withdrawalRecord['amount'],
                'transaction_id' => $transactionId,
                'estimated_confirmation_time' => '10-15 minutes'
            ]);
            
            // Step 11: Setup monitoring
            $this->addTransactionToMonitoring($transactionId, $withdrawalRecord['id']);
            
            echo "✅ Successfully processed withdrawal {$withdrawalRecord['id']} for user {$withdrawalRecord['user_id']}\n";
            
            return [
                'success' => true,
                'transaction_id' => $transactionId,
                'transaction_hash' => $transactionResult['transaction_hash'],
                'estimated_confirmation_time' => '10-15 minutes'
            ];
            
        } catch (Exception $error) {
            echo "❌ Withdrawal processing failed: " . $error->getMessage() . "\n";
            
            // Update withdrawal status to failed
            $this->updateWithdrawalStatus($withdrawalRecord['id'], 'failed');
            $this->addWithdrawalErrorLog($withdrawalRecord['id'], $error->getMessage());
            
            // Notify admins
            $this->notifyAdminsWithdrawalFailed($withdrawalRecord, $error->getMessage());
            
            throw $error;
        }
    }
    
    private function syncWallet() {
        $request = new \Tari\Rpc\GetStateRequest();
        
        list($response, $status) = $this->walletClient->GetState(
            $request,
            $this->metadata
        )->wait();
        
        if ($status->code !== Grpc\STATUS_OK) {
            throw new Exception("Failed to sync wallet: " . $status->details);
        }
        
        return $response;
    }
    
    private function getWalletBalance() {
        $request = new \Tari\Rpc\GetBalanceRequest();
        
        list($response, $status) = $this->walletClient->GetBalance(
            $request,
            $this->metadata
        )->wait();
        
        if ($status->code !== Grpc\STATUS_OK) {
            throw new Exception("Failed to get balance: " . $status->details);
        }
        
        return $response;
    }
    
    private function getTransactionDetails(int $transactionId) {
        $request = new \Tari\Rpc\GetTransactionInfoRequest([
            'transaction_ids' => [$transactionId]
        ]);
        
        list($response, $status) = $this->walletClient->GetTransactionInfo(
            $request,
            $this->metadata
        )->wait();
        
        if ($status->code === Grpc\STATUS_OK && $response->getTransactions()) {
            return $response->getTransactions()[0];
        }
        
        return null;
    }
    
    private function updateWithdrawalCompletion(array $withdrawalRecord, array $transactionResult): void {
        try {
            // Start database transaction
            $this->database->beginTransaction();
            
            // Update withdrawal status
            $this->updateWithdrawalStatus($withdrawalRecord['id'], 'completed');
            
            // Update transaction info
            $this->updateWithdrawalTransactionInfo($withdrawalRecord['id'], $transactionResult);
            
            // Deduct from user's reserved balance
            $this->deductReservedBalance(
                $withdrawalRecord['user_id'],
                $withdrawalRecord['amount'] + $withdrawalRecord['fee']
            );
            
            // Create audit log
            $this->createAuditLog([
                'action' => 'withdrawal_processed',
                'user_id' => $withdrawalRecord['user_id'],
                'amount' => $withdrawalRecord['amount'],
                'transaction_id' => $transactionResult['transaction_id'],
                'destination_address' => $withdrawalRecord['destination_address'],
                'processed_by' => $this->getCurrentOperator(),
                'timestamp' => date('Y-m-d H:i:s')
            ]);
            
            // Commit transaction
            $this->database->commit();
            
        } catch (Exception $error) {
            $this->database->rollBack();
            throw $error;
        }
    }
    
    private function isWithdrawalExpired(array $withdrawalRecord): bool {
        $expirationTime = 24 * 60 * 60; // 24 hours in seconds
        return time() - strtotime($withdrawalRecord['created_at']) > $expirationTime;
    }
    
    // Helper methods (implement based on your system)
    private function updateWithdrawalStatus(string $withdrawalId, string $status): void {
        // Implementation
    }
    
    private function markWithdrawalAsExpired(string $withdrawalId): void {
        // Implementation
    }
    
    private function isAddressCompromised(string $address): bool {
        // Implementation
        return false;
    }
    
    private function notifyAdminsLowBalance(int $available, int $required): void {
        // Implementation
    }
    
    private function notifyUserWithdrawalCompleted(string $userId, array $details): void {
        // Implementation
    }
    
    private function notifyAdminsWithdrawalFailed(array $withdrawal, string $error): void {
        // Implementation
    }
    
    private function addTransactionToMonitoring(int $txId, string $withdrawalId): void {
        // Implementation
    }
    
    private function addWithdrawalErrorLog(string $withdrawalId, string $error): void {
        // Implementation
    }
    
    private function updateWithdrawalTransactionInfo(string $withdrawalId, array $txInfo): void {
        // Implementation
    }
    
    private function deductReservedBalance(string $userId, int $amount): void {
        // Implementation
    }
    
    private function createAuditLog(array $logEntry): void {
        // Implementation
    }
    
    private function getCurrentOperator(): string {
        return 'system';
    }
}
?></code></pre>
            </div>
        </div>

<h2 id="security-best-practices">🔐 7. Security Best Practices</h2>

        <div class="warning">
            <strong>⚠️ Critical:</strong> Cryptocurrency exchange security requires defense in depth. Multiple layers of security are essential to protect user funds.
        </div>

        <h3>🛡️ Multi-Layer Security Architecture</h3>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'security-overview')">Security Overview</button>
                <button class="tab-button" onclick="switchTab(event, 'access-control')">Access Control</button>
                <button class="tab-button" onclick="switchTab(event, 'monitoring')">Security Monitoring</button>
                <button class="tab-button" onclick="switchTab(event, 'incident-response')">Incident Response</button>
            </div>
            
            <div id="security-overview" class="tab-content active">
                <div class="pseudocode-box">
                    <h4>🧠 Security Implementation Logic</h4>
                    <pre><code>FUNCTION implementSecurityMeasures():
    // Layer 1: Network Security
    configureFirewall([
        "ALLOW 18141/tcp FROM trusted_peers",
        "ALLOW 18142/tcp FROM localhost ONLY",
        "ALLOW 18143/tcp FROM localhost ONLY", 
        "DENY ALL other traffic"
    ])
    
    // Layer 2: Authentication & Authorization
    implementMFA({
        admin_accounts: "hardware_tokens_required",
        operator_accounts: "totp_required",
        api_access: "jwt_with_refresh_rotation"
    })
    
    // Layer 3: Wallet Security
    separateWallets({
        hot_wallet: {
            balance_limit: "1% of total funds",
            withdrawal_limit: "daily_maximum",
            monitoring: "real_time"
        },
        cold_storage: {
            air_gapped: true,
            multi_signature: "3_of_5_scheme",
            hardware_security_module: true
        }
    })
    
    // Layer 4: Data Protection
    encryptSensitiveData({
        keys: "AES-256-GCM",
        database: "TDE_enabled",
        backups: "encrypted_at_rest",
        transmission: "TLS_1.3_minimum"
    })
    
    // Layer 5: Monitoring & Alerting
    implementMonitoring({
        failed_logins: "immediate_alert_after_3",
        large_withdrawals: "manual_approval_required",
        unusual_patterns: "ML_based_detection",
        system_health: "24_7_monitoring"
    })
    
    RETURN security_status</code></pre>
                </div>
            </div>
            
            <div id="access-control" class="tab-content">
                <pre><code># Role-Based Access Control (RBAC) Configuration

## Admin Role (Full Access)
- Wallet management
- System configuration  
- User account management
- Financial controls
- Security settings

## Operator Role (Limited Access)
- Transaction monitoring
- Customer support
- Basic reporting
- Limited withdrawal approval

## Auditor Role (Read-Only)
- Transaction history
- System logs
- Compliance reports
- Security audit trails

## API Service Account
- Programmatic access only
- Rate limited
- IP restricted
- Specific endpoint permissions

# Implementation Example
sudo groupadd tari-admins
sudo groupadd tari-operators
sudo groupadd tari-auditors

# Configure sudo access
echo '%tari-admins ALL=(ALL) ALL' > /etc/sudoers.d/tari-admins
echo '%tari-operators ALL=(tari) NOPASSWD: /usr/local/bin/tari-operator-tools' > /etc/sudoers.d/tari-operators</code></pre>
            </div>
            
            <div id="monitoring" class="tab-content">
                <pre><code># Security Monitoring Implementation

## File Integrity Monitoring
sudo apt-get install aide
sudo aideinit
sudo aide --check

## Log Monitoring with ELK Stack
version: '3.7'
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.15.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=true
    
  logstash:
    image: docker.elastic.co/logstash/logstash:7.15.0
    volumes:
      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf
    
  kibana:
    image: docker.elastic.co/kibana/kibana:7.15.0
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200

## Real-time Alerting Rules
input {
  file {
    path => "/var/log/tari/*.log"
    type => "tari"
  }
}

filter {
  if [type] == "tari" {
    if "FAILED_LOGIN" in [message] {
      mutate { add_tag => [ "security_alert" ] }
    }
    if "LARGE_WITHDRAWAL" in [message] {
      mutate { add_tag => [ "financial_alert" ] }
    }
  }
}

output {
  if "security_alert" in [tags] {
    http {
      url => "https://alerts.yourexchange.com/webhook"
      http_method => "post"
    }
  }
}</code></pre>
            </div>
            
            <div id="incident-response" class="tab-content">
                <pre><code># Incident Response Procedures

## Immediate Response (0-15 minutes)
1. Identify incident type
2. Activate incident response team
3. Isolate affected systems
4. Preserve evidence

## Assessment Phase (15-60 minutes)
1. Determine scope of breach
2. Assess fund security
3. Check system integrity
4. Document timeline

## Containment (1-4 hours)
1. Stop unauthorized access
2. Patch vulnerabilities
3. Reset compromised credentials
4. Secure backup systems

## Recovery (4-24 hours)
1. Restore from clean backups
2. Verify system integrity
3. Resume operations gradually
4. Monitor for reoccurrence

## Post-Incident (24+ hours)
1. Conduct thorough investigation
2. Update security measures
3. Report to authorities if required
4. Communicate with stakeholders

# Emergency Contacts
SECURITY_TEAM="security@yourexchange.com"
CEO_PHONE="+1-555-0123"
CTO_PHONE="+1-555-0124"
LEGAL_COUNSEL="+1-555-0125"

# Automated Incident Response
#!/bin/bash
# incident-response.sh

INCIDENT_TYPE=$1
SEVERITY=$2

case $INCIDENT_TYPE in
  "unauthorized_access")
    # Immediately disable compromised accounts
    ./disable-accounts.sh --compromised
    # Alert security team
    ./send-alert.sh "SECURITY BREACH DETECTED" $SEVERITY
    ;;
  "large_withdrawal")
    # Freeze withdrawal processing
    ./freeze-withdrawals.sh
    # Require manual approval
    ./require-manual-approval.sh
    ;;
  "system_compromise")
    # Isolate affected systems
    ./isolate-systems.sh
    # Contact incident response team
    ./emergency-contact.sh
    ;;
esac</code></pre>
            </div>
        </div>

        <h2 id="production-deployment">🚀 8. Production Deployment</h2>

        <div class="info">
            <strong>📋 Production Ready:</strong> Deploying Tari in production requires careful planning, monitoring, and redundancy. This section covers Docker, Kubernetes, and monitoring setups.
        </div>

        <h3>🐳 Docker Deployment</h3>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'docker-compose')">Docker Compose</button>
                <button class="tab-button" onclick="switchTab(event, 'dockerfile')">Dockerfile</button>
                <button class="tab-button" onclick="switchTab(event, 'k8s-deployment')">Kubernetes</button>
            </div>
            
            <div id="docker-compose" class="tab-content active">
                <pre><code>version: '3.8'

services:
  tari-node:
    # WARNING: Use specific version tags in production, not 'latest'
        image: tariproject/minotari_node:latest
    container_name: tari-node
    restart: unless-stopped
    ports:
      - "18141:18141"  # P2P port
      - "127.0.0.1:18142:18142"  # gRPC port (localhost only)
    volumes:
      - tari-node-data:/root/.tari
      - ./config/node-config.toml:/root/.tari/mainnet/config/config.toml:ro
    environment:
      - TARI_NETWORK=mainnet
      - RUST_LOG=info
    networks:
      - tari-network

  tari-wallet:
    image: tariproject/minotari_console_wallet:latest
    container_name: tari-wallet
    restart: unless-stopped
    ports:
      - "127.0.0.1:18143:18143"  # gRPC port (localhost only)
    volumes:
      - tari-wallet-data:/root/.tari
      - ./config/wallet-config.toml:/root/.tari/mainnet/config/config.toml:ro
    environment:
      - TARI_NETWORK=mainnet
      - TARI_WALLET__CUSTOM_BASE_NODE=tari-node:18142
    depends_on:
      - tari-node
    networks:
      - tari-network

  redis:
    image: redis:7-alpine
    container_name: tari-redis
    restart: unless-stopped
    volumes:
      - redis-data:/data
    networks:
      - tari-network

  postgres:
    image: postgres:15
    container_name: tari-postgres
    restart: unless-stopped
    environment:
      - POSTGRES_DB=tari_exchange
      - POSTGRES_USER=tari_user
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - tari-network

  exchange-api:
    build: .
    container_name: tari-exchange-api
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://tari_user:${DB_PASSWORD}@postgres:5432/tari_exchange
      - REDIS_URL=redis://redis:6379
      - TARI_WALLET_GRPC=http://tari-wallet:18143
      - TARI_NODE_GRPC=http://tari-node:18142
    depends_on:
      - postgres
      - redis
      - tari-wallet
    networks:
      - tari-network

volumes:
  tari-node-data:
  tari-wallet-data:
  redis-data:
  postgres-data:

networks:
  tari-network:
    driver: bridge</code></pre>
            </div>
            
            <div id="dockerfile" class="tab-content">
                <pre><code># Multi-stage Dockerfile for Node.js exchange API
FROM node:18-alpine AS builder

# Install build dependencies
RUN apk add --no-cache python3 make g++

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY . .

# Build application
RUN npm run build

# Production stage
FROM node:18-alpine AS production

# Install security updates
RUN apk upgrade --no-cache

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S tari -u 1001

WORKDIR /app

# Copy built application
COPY --from=builder --chown=tari:nodejs /app/dist ./dist
COPY --from=builder --chown=tari:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=tari:nodejs /app/package.json ./

# Switch to non-root user
USER tari

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node dist/healthcheck.js

# Expose port
EXPOSE 3000

# Start application
CMD ["node", "dist/index.js"]</code></pre>
            </div>
            
            <div id="k8s-deployment" class="tab-content">
                <pre><code># Kubernetes deployment for Tari exchange
apiVersion: v1
kind: Namespace
metadata:
  name: tari-exchange

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: tari-config
  namespace: tari-exchange
data:
  node-config.toml: |
    [base_node.mainnet]
    grpc_enabled = true
    grpc_base_node_address = "http://0.0.0.0:18142"
    transport = "tor"
    allow_test_addresses = false
    
  wallet-config.toml: |
    [wallet]
    grpc_enabled = true
    grpc_address = "http://0.0.0.0:18143"
    grpc_authentication = { username = "exchange", password = "secure_password" }

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tari-node
  namespace: tari-exchange
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tari-node
  template:
    metadata:
      labels:
        app: tari-node
    spec:
      containers:
      - name: tari-node
        # WARNING: Use specific version tags in production, not 'latest'
        image: tariproject/minotari_node:latest
        ports:
        - containerPort: 18141
        - containerPort: 18142
        volumeMounts:
        - name: tari-data
          mountPath: /root/.tari
        - name: config
          mountPath: /root/.tari/mainnet/config/config.toml
          subPath: node-config.toml
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
      volumes:
      - name: tari-data
        persistentVolumeClaim:
          claimName: tari-node-pvc
      - name: config
        configMap:
          name: tari-config

---
apiVersion: v1
kind: Service
metadata:
  name: tari-node-service
  namespace: tari-exchange
spec:
  selector:
    app: tari-node
  ports:
  - name: grpc
    port: 18142
    targetPort: 18142
  type: ClusterIP

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: tari-node-pvc
  namespace: tari-exchange
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi
  storageClassName: fast-ssd</code></pre>
            </div>
        </div>

        <h2 id="troubleshooting">🔧 9. Troubleshooting</h2>

        <div class="info">
            <strong>🔧 Common Issues:</strong> This section covers the most frequently encountered problems and their solutions when integrating Tari into exchanges.
        </div>

        <h3>🐛 Common Issues and Solutions</h3>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'sync-issues')">Sync Issues</button>
                <button class="tab-button" onclick="switchTab(event, 'connectivity-issues')">Connectivity</button>
                <button class="tab-button" onclick="switchTab(event, 'transaction-issues')">Transactions</button>
                <button class="tab-button" onclick="switchTab(event, 'performance-issues')">Performance</button>
            </div>
            
            <div id="sync-issues" class="tab-content active">
                <div class="grpcurl-box">
                    <h4>🧪 Sync Troubleshooting with grpcurl</h4>
                    <pre><code># Check node sync status
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetSyncInfo

# Check tip info
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetTipInfo

# Check connected peers
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/ListConnectedPeers

# Complete sync diagnostic script
#!/bin/bash
echo "=== Sync Diagnostic Script ==="

echo "1. Base Node Sync Status:"
SYNC_INFO=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetSyncInfo 2>/dev/null)
if [ $? -eq 0 ]; then
    echo "$SYNC_INFO" | jq .
else
    echo "❌ Cannot connect to base node"
fi

echo -e "\n2. Peer Connections:"
PEERS=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/ListConnectedPeers 2>/dev/null)
PEER_COUNT=$(echo "$PEERS" | jq '.connected_peers | length')
echo "Connected peers: $PEER_COUNT"

if [ "$PEER_COUNT" -lt 3 ]; then
    echo "⚠️  Low peer count, checking network..."
    # Add more peers manually if needed
fi

echo -e "\n3. Wallet Sync Status:"
WALLET_STATE=$(grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetState 2>/dev/null)
if [ $? -eq 0 ]; then
    SCANNED_HEIGHT=$(echo "$WALLET_STATE" | jq -r '.scanned_height')
    echo "Wallet scanned height: $SCANNED_HEIGHT"
else
    echo "❌ Cannot connect to wallet"
fi

# Common fixes for sync issues:
echo -e "\n🔧 Common Sync Fixes:"
echo "1. Restart services: docker-compose restart"
echo "2. Clear peer ban list: rm ~/.tari/mainnet/peer_db/banned_peers"
echo "3. Manual peer addition: Use SetBaseNode RPC call"</code></pre>
                </div>
            </div>
            
            <div id="connectivity-issues" class="tab-content">
                <pre><code># Network connectivity troubleshooting

## Check port accessibility
sudo netstat -tlnp | grep -E "(18141|18142|18143)"

## Test gRPC connectivity
grpcurl -plaintext -connect-timeout 10 localhost:18142 list
grpcurl -plaintext -connect-timeout 10 localhost:18143 list

## Firewall rules check
sudo iptables -L -n | grep -E "(18141|18142|18143)"

## DNS resolution for Tor (if using)
nslookup facebook.com # Should fail if properly isolated
curl --socks5 127.0.0.1:9050 http://check.torproject.org/

## Docker network troubleshooting
docker network ls
docker network inspect tari_tari-network

# Common connectivity fixes:
# 1. Check firewall settings
sudo ufw allow 18141
sudo ufw deny 18142 # gRPC should be localhost only
sudo ufw deny 18143 # gRPC should be localhost only

# 2. Verify Docker networking
docker exec tari-node ping tari-wallet
docker exec tari-wallet ping tari-node</code></pre>
            </div>
            
            <div id="transaction-issues" class="tab-content">
                <div class="grpcurl-box">
                    <h4>🧪 Transaction Debugging with grpcurl</h4>
                    <pre><code># Check specific transaction status
TX_ID=12345
grpcurl -plaintext \
  -d "{\"transaction_ids\": [$TX_ID]}" \
  localhost:18143 \
  tari.rpc.Wallet/GetTransactionInfo

# Check mempool for pending transactions
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetMempoolStats
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetMempoolTransactions

# Search for transaction by commitment
COMMITMENT="your_commitment_hex"
grpcurl -plaintext \
  -d "{\"commitments\": [\"$COMMITMENT\"]}" \
  localhost:18142 \
  tari.rpc.BaseNode/SearchUtxos

# Transaction debugging script
#!/bin/bash
TX_ID="${1:-}"

if [ -z "$TX_ID" ]; then
    echo "Usage: $0 <transaction_id>"
    exit 1
fi

echo "=== Transaction Debugging: $TX_ID ==="

echo "1. Wallet transaction info:"
TX_INFO=$(grpcurl -plaintext \
  -d "{\"transaction_ids\": [$TX_ID]}" \
  localhost:18143 \
  tari.rpc.Wallet/GetTransactionInfo 2>/dev/null)

if [ $? -eq 0 ] && [ -n "$TX_INFO" ]; then
    echo "$TX_INFO" | jq .
    
    STATUS=$(echo "$TX_INFO" | jq -r '.transactions[0].status')
    echo "Transaction Status: $STATUS"
    
    if [ "$STATUS" = "TRANSACTION_STATUS_PENDING" ]; then
        echo "⏳ Transaction is pending..."
        echo "2. Checking mempool:"
        grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetMempoolStats
    fi
else
    echo "❌ Transaction not found in wallet"
fi

echo -e "\n🔧 Common Transaction Fixes:"
echo "1. Wait for confirmation (10-15 minutes typical)"
echo "2. Check if fee is sufficient"
echo "3. Verify recipient address format"
echo "4. Ensure wallet is synced"</code></pre>
                </div>
            </div>
            
            <div id="performance-issues" class="tab-content">
                <pre><code># Performance monitoring and optimization

## System resource monitoring
top -p $(pgrep minotari)
iostat -x 1 5
free -h
df -h

## Database performance (if using PostgreSQL)
sudo -u postgres psql -c "SELECT * FROM pg_stat_activity;"
sudo -u postgres psql -c "SELECT schemaname,tablename,n_tup_ins,n_tup_upd,n_tup_del FROM pg_stat_user_tables;"

## gRPC performance monitoring
# Monitor response times
time grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetState
time grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetTipInfo

## Log analysis for performance issues
tail -f ~/.tari/mainnet/logs/base_node.log | grep -E "(slow|timeout|error)"
tail -f ~/.tari/mainnet/logs/wallet.log | grep -E "(slow|timeout|error)"

# Performance optimization checklist:
# [ ] SSD storage for blockchain data
# [ ] Sufficient RAM (8GB+ recommended)
# [ ] Fast network connection
# [ ] Regular database maintenance
# [ ] Log rotation configured
# [ ] Monitoring alerts set up

## Docker performance optimization
# Use volume mounts instead of bind mounts for better I/O
# Allocate sufficient resources
docker stats tari-node tari-wallet</code></pre>
            </div>
        </div>

        <h2 id="api-reference">📚 10. Complete API Reference</h2>

        <div class="info">
            <strong>📋 Complete Reference:</strong> All gRPC methods available for Tari wallet and base node integration with pseudocode and grpcurl examples.
        </div>

        <h3>💼 Wallet API Methods</h3>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'wallet-core-ref')">Core Methods</button>
                <button class="tab-button" onclick="switchTab(event, 'wallet-tx-ref')">Transaction Methods</button>
                <button class="tab-button" onclick="switchTab(event, 'wallet-advanced-ref')">Advanced Methods</button>
            </div>
            
            <div id="wallet-core-ref" class="tab-content active">
                <div class="pseudocode-box">
                    <h4>🧠 Core Wallet Operations Logic</h4>
                    <pre><code>// Core wallet operations provide basic wallet information and state

FUNCTION getWalletVersion():
    // Simple version check - no parameters needed
    RETURN walletClient.GetVersion()

FUNCTION getWalletState():
    // Returns comprehensive wallet status including:
    // - Blockchain sync height
    // - Balance information
    // - Network connectivity status
    RETURN walletClient.GetState()

FUNCTION checkWalletConnectivity():
    // Quick connectivity check without full state
    RETURN walletClient.CheckConnectivity()

FUNCTION getWalletIdentity():
    // Returns wallet's public key and addresses
    RETURN walletClient.Identify()

FUNCTION getWalletAddresses():
    // Get basic address formats (binary)
    RETURN walletClient.GetAddress()

FUNCTION getCompleteAddresses():
    // Get all address formats (binary, base58, emoji)
    RETURN walletClient.GetCompleteAddress()

FUNCTION generateAddressWithPaymentId(paymentId):
    // Generate address tied to specific payment ID
    paymentIdBytes = convertToBytes(paymentId)
    RETURN walletClient.GetPaymentIdAddress(paymentIdBytes)</code></pre>
                </div>
                
                <div class="grpcurl-box">
                    <h4>🧪 Core Wallet Methods with grpcurl</h4>
                    <pre><code># 1. Get Wallet Version
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetVersion

# 2. Get Wallet State (comprehensive status)
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetState

# 3. Quick Connectivity Check
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/CheckConnectivity

# 4. Get Wallet Identity
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/Identify

# 5. Get Basic Addresses
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetAddress

# 6. Get Complete Address Information
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetCompleteAddress

# 7. Generate Address with Payment ID
PAYMENT_ID="deposit-user123-$(date +%s)"
PAYMENT_ID_B64=$(echo -n "$PAYMENT_ID" | base64 -w 0)

grpcurl -plaintext \
  -d "{\"payment_id\": \"$PAYMENT_ID_B64\"}" \
  localhost:18143 \
  tari.rpc.Wallet/GetPaymentIdAddress

# Complete wallet status check script
#!/bin/bash
echo "=== Wallet Status Check ==="

echo "1. Version:"
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetVersion

echo -e "\n2. Connectivity:"
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/CheckConnectivity

echo -e "\n3. State:"
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetState

echo -e "\n4. Identity:"
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/Identify</code></pre>
                </div>
            </div>
            
            <div id="wallet-tx-ref" class="tab-content">
                <div class="pseudocode-box">
                    <h4>🧠 Transaction Operations Logic</h4>
                    <pre><code>// Transaction operations for sending funds and querying transaction history

FUNCTION sendFunds(recipients):
    // Send funds to one or more recipients
    // Each recipient needs: address, amount, fee_per_gram, payment_type, payment_id
    FOR EACH recipient IN recipients:
        validateAddress(recipient.address)
        validateAmount(recipient.amount)
        validatePaymentType(recipient.payment_type) // ONE_SIDED for exchanges
    
    request = {recipients: recipients}
    RETURN walletClient.Transfer(request)

FUNCTION getTransactionInfo(transactionIds):
    // Get detailed information for specific transactions
    request = {transaction_ids: transactionIds}
    RETURN walletClient.GetTransactionInfo(request)

FUNCTION getCompletedTransactions(filter):
    // Stream completed transactions, optionally filtered
    // Filter can be: payment_id, block_hash, block_height
    request = createFilteredRequest(filter)
    RETURN walletClient.GetCompletedTransactions(request) // Returns stream

FUNCTION cancelTransaction(transactionId):
    // Cancel a pending transaction
    request = {tx_id: transactionId}
    RETURN walletClient.CancelTransaction(request)

FUNCTION streamTransactionEvents():
    // Monitor real-time transaction events
    RETURN walletClient.StreamTransactionEvents() // Returns stream

FUNCTION processTransactionStream():
    stream = streamTransactionEvents()
    WHILE (event = stream.next()):
        IF (event.type == "Mined" AND event.direction == "Inbound"):
            processIncomingDeposit(event)
        ELSE IF (event.type == "Cancelled"):
            handleCancelledTransaction(event)</code></pre>
                </div>
                
                <div class="grpcurl-box">
                    <h4>🧪 Transaction Methods with grpcurl</h4>
                    <pre><code># 1. Send Funds (ONE_SIDED transaction for exchanges)
RECIPIENT="12HVCEeZC2RGE4SDn3yGwqz..."  # Replace with actual address
AMOUNT=1000000  # 1 XTM in microXTM
PAYMENT_ID="withdraw-$(date +%s)-$(openssl rand -hex 4)"
PAYMENT_ID_B64=$(echo -n "$PAYMENT_ID" | base64 -w 0)

grpcurl -plaintext \
  -d "{
    \"recipients\": [{
      \"address\": \"$RECIPIENT\",
      \"amount\": $AMOUNT,
      \"fee_per_gram\": 25,
      \"payment_type\": \"ONE_SIDED\",
      \"payment_id\": \"$PAYMENT_ID_B64\"
    }]
  }" \
  localhost:18143 \
  tari.rpc.Wallet/Transfer

# 2. Get Transaction Information
TX_ID=12345  # Replace with actual transaction ID
grpcurl -plaintext \
  -d "{\"transaction_ids\": [$TX_ID]}" \
  localhost:18143 \
  tari.rpc.Wallet/GetTransactionInfo

# 3. Get All Completed Transactions
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetCompletedTransactions

# 4. Get Transactions for Specific Payment ID
PAYMENT_ID="deposit-user123-abc456"
grpcurl -plaintext \
  -d "{\"payment_id\": {\"utf8_string\": \"$PAYMENT_ID\"}}" \
  localhost:18143 \
  tari.rpc.Wallet/GetCompletedTransactions

# 5. Get Transactions for Specific Block
BLOCK_HASH="a1b2c3d4e5f6..."
grpcurl -plaintext \
  -d "{\"block_hash\": {\"hash\": \"$BLOCK_HASH\"}}" \
  localhost:18143 \
  tari.rpc.Wallet/GetCompletedTransactions

# 6. Cancel Transaction
TX_ID=12345
grpcurl -plaintext \
  -d "{\"tx_id\": $TX_ID}" \
  localhost:18143 \
  tari.rpc.Wallet/CancelTransaction

# 7. Stream Real-time Transaction Events
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/StreamTransactionEvents

# Transaction monitoring script
#!/bin/bash
echo "=== Transaction Monitoring ==="

echo "1. Recent Transactions:"
timeout 10s grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetCompletedTransactions | head -20

echo -e "\n2. Real-time Events (monitoring for 30 seconds):"
timeout 30s grpcurl -plaintext localhost:18143 tari.rpc.Wallet/StreamTransactionEvents | \
while read -r line; do
    echo "$(date): $line"
done</code></pre>
                </div>
            </div>
            
            <div id="wallet-advanced-ref" class="tab-content">
                <div class="pseudocode-box">
                    <h4>🧠 Advanced Wallet Operations Logic</h4>
                    <pre><code>// Advanced wallet operations for balance management and network operations

FUNCTION getBalance(paymentId):
    // Get balance, optionally filtered by payment ID
    IF (paymentId IS provided):
        request = {payment_id: convertPaymentId(paymentId)}
    ELSE:
        request = {} // Get total wallet balance
    
    RETURN walletClient.GetBalance(request)

FUNCTION splitCoins(amountPerSplit, splitCount, feePerGram):
    // Split large UTXOs into smaller ones for better transaction management
    validateAmount(amountPerSplit)
    validateCount(splitCount)
    
    request = {
        amount_per_split: amountPerSplit,
        split_count: splitCount,
        fee_per_gram: feePerGram,
        lock_height: 0
    }
    
    RETURN walletClient.CoinSplit(request)

FUNCTION importUTXOs(outputs, paymentId):
    // Import external UTXOs into wallet
    FOR EACH output IN outputs:
        validateUTXO(output)
    
    request = {
        outputs: outputs,
        payment_id: paymentId
    }
    
    RETURN walletClient.ImportUtxos(request)

FUNCTION getNetworkStatus():
    // Get detailed network connectivity information
    RETURN walletClient.GetNetworkStatus()

FUNCTION listConnectedPeers():
    // Get list of currently connected peers
    RETURN walletClient.ListConnectedPeers()

FUNCTION setBaseNode(publicKey, address):
    // Configure which base node to connect to
    request = {
        public_key_hex: publicKey,
        net_address: address
    }
    
    RETURN walletClient.SetBaseNode(request)

FUNCTION revalidateTransactions():
    // Force revalidation of all wallet transactions
    RETURN walletClient.RevalidateAllTransactions()</code></pre>
                </div>
                
                <div class="grpcurl-box">
                    <h4>🧪 Advanced Methods with grpcurl</h4>
                    <pre><code># 1. Get Total Balance
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetBalance

# 2. Get Balance for Specific Payment ID
PAYMENT_ID="deposit-user123"
grpcurl -plaintext \
  -d "{\"payment_id\": {\"utf8_string\": \"$PAYMENT_ID\"}}" \
  localhost:18143 \
  tari.rpc.Wallet/GetBalance

# 3. Get Unspent Amounts
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetUnspentAmounts

# 4. Coin Split (create 10 outputs of 0.1 XTM each)
grpcurl -plaintext \
  -d "{
    \"amount_per_split\": 100000,
    \"split_count\": 10,
    \"fee_per_gram\": 25,
    \"lock_height\": 0
  }" \
  localhost:18143 \
  tari.rpc.Wallet/CoinSplit

# 5. Get Network Status
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetNetworkStatus

# 6. List Connected Peers
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/ListConnectedPeers

# 7. Set Base Node
NODE_PUBKEY="90f67a04edcb36261e6304ca213629d183c44e26bd47e38c253473f44d901733"
NODE_ADDRESS="/onion3/f5qbkkfkoxowzvshe5mppzpgiiy76cwumpsacungeldoal6hehcgzfqd:18141"

grpcurl -plaintext \
  -d "{
    \"public_key_hex\": \"$NODE_PUBKEY\",
    \"net_address\": \"$NODE_ADDRESS\"
  }" \
  localhost:18143 \
  tari.rpc.Wallet/SetBaseNode

# 8. Revalidate All Transactions
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/RevalidateAllTransactions

# Comprehensive wallet health check
#!/bin/bash
echo "=== Advanced Wallet Health Check ==="

echo "1. Balance Information:"
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetBalance | jq .

echo -e "\n2. Network Status:"
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetNetworkStatus | jq .

echo -e "\n3. Connected Peers:"
PEER_COUNT=$(grpcurl -plaintext localhost:18143 tari.rpc.Wallet/ListConnectedPeers | jq '.connected_peers | length')
echo "Connected peers: $PEER_COUNT"

echo -e "\n4. Unspent Outputs:"
grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetUnspentAmounts | jq .

# Check if wallet needs coin splitting
BALANCE=$(grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetBalance | jq -r '.available_balance // 0')
UNSPENT_COUNT=$(grpcurl -plaintext localhost:18143 tari.rpc.Wallet/GetUnspentAmounts | jq '.amount | length')

echo -e "\n5. UTXO Analysis:"
echo "Available balance: $BALANCE microXTM"
echo "Number of UTXOs: $UNSPENT_COUNT"

if [ "$UNSPENT_COUNT" -lt 5 ] && [ "$BALANCE" -gt 10000000 ]; then
    echo "💡 Consider coin splitting for better transaction management"
fi</code></pre>
                </div>
            </div>
        </div>

        <h3>⛓️ Base Node API Methods</h3>

        <div class="code-tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab(event, 'node-info-ref')">Node Information</button>
                <button class="tab-button" onclick="switchTab(event, 'node-blockchain-ref')">Blockchain Data</button>
                <button class="tab-button" onclick="switchTab(event, 'node-network-ref')">Network Methods</button>
            </div>
            
            <div id="node-info-ref" class="tab-content active">
                <div class="pseudocode-box">
                    <h4>🧠 Node Information Logic</h4>
                    <pre><code>// Base node information provides blockchain state and node status

FUNCTION getNodeVersion():
    // Get base node software version
    RETURN baseNodeClient.GetVersion()

FUNCTION getNodeIdentity():
    // Get node's public key, addresses, and network identity
    RETURN baseNodeClient.Identify()

FUNCTION getTipInfo():
    // Get current blockchain tip information including:
    // - Best block height and hash
    // - Accumulated difficulty
    // - Sync status
    RETURN baseNodeClient.GetTipInfo()

FUNCTION getSyncInfo():
    // Get detailed synchronization status
    RETURN baseNodeClient.GetSyncInfo()

FUNCTION getSyncProgress():
    // Get sync progress with state information
    RETURN baseNodeClient.GetSyncProgress()

FUNCTION getConsensusConstants(blockHeight):
    // Get network consensus rules for specific block height
    request = {block_height: blockHeight}
    RETURN baseNodeClient.GetConstants(request)

FUNCTION checkForUpdates():
    // Check if newer software version is available
    RETURN baseNodeClient.CheckForUpdates()

FUNCTION getNetworkState():
    // Get comprehensive network state including peers and difficulty
    RETURN baseNodeClient.GetNetworkState()</code></pre>
                </div>
                
                <div class="grpcurl-box">
                    <h4>🧪 Node Information with grpcurl</h4>
                    <pre><code># 1. Get Node Version
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetVersion

# 2. Get Node Identity
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/Identify

# 3. Get Tip Information (current blockchain state)
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetTipInfo

# 4. Get Sync Information
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetSyncInfo

# 5. Get Sync Progress Details
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetSyncProgress

# 6. Get Consensus Constants for Current Tip
TIP_HEIGHT=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetTipInfo | jq -r '.metadata.best_block_height // 0')
grpcurl -plaintext \
  -d "{\"block_height\": $TIP_HEIGHT}" \
  localhost:18142 \
  tari.rpc.BaseNode/GetConstants

# 7. Check for Software Updates
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/CheckForUpdates

# 8. Get Network State
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetNetworkState

# Complete node status script
#!/bin/bash
echo "=== Base Node Status Check ==="

echo "1. Node Version:"
VERSION=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetVersion 2>/dev/null | jq -r '.value // "Unknown"')
echo "Version: $VERSION"

echo -e "\n2. Node Identity:"
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/Identify | jq .

echo -e "\n3. Blockchain Status:"
TIP_INFO=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetTipInfo 2>/dev/null)
if [ $? -eq 0 ]; then
    HEIGHT=$(echo "$TIP_INFO" | jq -r '.metadata.best_block_height // 0')
    HASH=$(echo "$TIP_INFO" | jq -r '.metadata.best_block_hash // "unknown"')
    SYNC_STATUS=$(echo "$TIP_INFO" | jq -r '.initial_sync_achieved // false')
    
    echo "Height: $HEIGHT"
    echo "Hash: ${HASH:0:16}..."
    echo "Synced: $SYNC_STATUS"
else
    echo "❌ Could not get tip info"
fi

echo -e "\n4. Sync Progress:"
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetSyncProgress | jq .

echo -e "\n5. Software Updates:"
UPDATE_INFO=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/CheckForUpdates 2>/dev/null)
HAS_UPDATE=$(echo "$UPDATE_INFO" | jq -r '.has_update // false')
if [ "$HAS_UPDATE" = "true" ]; then
    NEW_VERSION=$(echo "$UPDATE_INFO" | jq -r '.version // "unknown"')
    echo "⚠️  Update available: $NEW_VERSION"
else
    echo "✅ Software up to date"
fi</code></pre>
                </div>
            </div>
            
            <div id="node-blockchain-ref" class="tab-content">
                <div class="grpcurl-box">
                    <h4>🧪 Blockchain Data with grpcurl</h4>
                    <pre><code># 1. List Recent Headers (last 10 blocks)
grpcurl -plaintext \
  -d "{\"num_headers\": 10, \"sorting\": \"SORTING_DESC\"}" \
  localhost:18142 \
  tari.rpc.BaseNode/ListHeaders

# 2. Get Headers from Specific Height
START_HEIGHT=100000
grpcurl -plaintext \
  -d "{\"from_height\": $START_HEIGHT, \"num_headers\": 5}" \
  localhost:18142 \
  tari.rpc.BaseNode/ListHeaders

# 3. Get Header by Hash
BLOCK_HASH="a1b2c3d4e5f6..."  # Replace with actual block hash
grpcurl -plaintext \
  -d "{\"hash\": \"$BLOCK_HASH\"}" \
  localhost:18142 \
  tari.rpc.BaseNode/GetHeaderByHash

# 4. Get Specific Blocks
grpcurl -plaintext \
  -d "{\"heights\": [100000, 100001, 100002]}" \
  localhost:18142 \
  tari.rpc.BaseNode/GetBlocks

# 5. Get Block Timing Statistics (last 100 blocks)
grpcurl -plaintext \
  -d "{\"from_tip\": 100}" \
  localhost:18142 \
  tari.rpc.BaseNode/GetBlockTiming

# 6. Get Block Size Statistics
grpcurl -plaintext \
  -d "{\"from_tip\": 100, \"calc_type\": \"MEDIAN\"}" \
  localhost:18142 \
  tari.rpc.BaseNode/GetBlockSize

# 7. Get Block Fee Statistics
grpcurl -plaintext \
  -d "{\"start_height\": 100000, \"end_height\": 100100, \"calc_type\": \"MEAN\"}" \
  localhost:18142 \
  tari.rpc.BaseNode/GetBlockFees

# 8. Get Network Difficulty (last 10 blocks)
grpcurl -plaintext \
  -d "{\"from_tip\": 10}" \
  localhost:18142 \
  tari.rpc.BaseNode/GetNetworkDifficulty

# 9. Get Tokens in Circulation
TIP_HEIGHT=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetTipInfo | jq -r '.metadata.best_block_height')
grpcurl -plaintext \
  -d "{\"heights\": [$TIP_HEIGHT]}" \
  localhost:18142 \
  tari.rpc.BaseNode/GetTokensInCirculation

# Blockchain analysis script
#!/bin/bash
echo "=== Blockchain Analysis ==="

# Get current tip
TIP_INFO=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetTipInfo 2>/dev/null)
TIP_HEIGHT=$(echo "$TIP_INFO" | jq -r '.metadata.best_block_height // 0')

echo "Current tip height: $TIP_HEIGHT"

if [ "$TIP_HEIGHT" -gt 0 ]; then
    echo -e "\n1. Recent Block Timing:"
    grpcurl -plaintext \
      -d "{\"from_tip\": 10}" \
      localhost:18142 \
      tari.rpc.BaseNode/GetBlockTiming | jq .
    
    echo -e "\n2. Network Difficulty (last 5 blocks):"
    grpcurl -plaintext \
      -d "{\"from_tip\": 5}" \
      localhost:18142 \
      tari.rpc.BaseNode/GetNetworkDifficulty | \
      jq '{height: .height, difficulty: .difficulty, hash_rate: .estimated_hash_rate}'
    
    echo -e "\n3. Block Size Statistics:"
    grpcurl -plaintext \
      -d "{\"from_tip\": 100, \"calc_type\": \"MEDIAN\"}" \
      localhost:18142 \
      tari.rpc.BaseNode/GetBlockSize | jq .
    
    echo -e "\n4. Circulating Supply:"
    grpcurl -plaintext \
      -d "{\"heights\": [$TIP_HEIGHT]}" \
      localhost:18142 \
      tari.rpc.BaseNode/GetTokensInCirculation | jq .
else
    echo "❌ Node not synced or not accessible"
fi</code></pre>
                </div>
            </div>
            
            <div id="node-network-ref" class="tab-content">
                <div class="grpcurl-box">
                    <h4>🧪 Network Methods with grpcurl</h4>
                    <pre><code># 1. Get Network Status
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetNetworkStatus

# 2. List Connected Peers
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/ListConnectedPeers

# 3. Get All Peers (including disconnected)
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetPeers

# 4. Get Mempool Statistics
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetMempoolStats

# 5. Get Mempool Transactions
grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetMempoolTransactions

# 6. Check Transaction State (by signature)
TX_SIGNATURE="3045022100..."  # Replace with actual transaction signature
grpcurl -plaintext \
  -d "{\"excess_sig\": {\"public_nonce\": \"...\", \"signature\": \"$TX_SIGNATURE\"}}" \
  localhost:18142 \
  tari.rpc.BaseNode/TransactionState

# 7. Search for UTXOs by Commitment
COMMITMENT="a1b2c3d4e5f6..."  # Replace with actual commitment
grpcurl -plaintext \
  -d "{\"commitments\": [\"$COMMITMENT\"]}" \
  localhost:18142 \
  tari.rpc.BaseNode/SearchUtxos

# 8. Search for Kernels by Signature
grpcurl -plaintext \
  -d "{\"signatures\": [{\"public_nonce\": \"...\", \"signature\": \"...\"}]}" \
  localhost:18142 \
  tari.rpc.BaseNode/SearchKernels

# 9. Fetch Matching UTXOs by Hash
UTXO_HASH="hash1,hash2,hash3"
grpcurl -plaintext \
  -d "{\"hashes\": [\"$UTXO_HASH\"]}" \
  localhost:18142 \
  tari.rpc.BaseNode/FetchMatchingUtxos

# Network monitoring script
#!/bin/bash
echo "=== Network Monitoring ==="

echo "1. Network Status:"
NETWORK_STATUS=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetNetworkStatus 2>/dev/null)
if [ $? -eq 0 ]; then
    STATUS=$(echo "$NETWORK_STATUS" | jq -r '.status')
    LATENCY=$(echo "$NETWORK_STATUS" | jq -r '.avg_latency_ms // 0')
    CONNECTIONS=$(echo "$NETWORK_STATUS" | jq -r '.num_node_connections // 0')
    
    echo "Status: $STATUS"
    echo "Connections: $CONNECTIONS"
    echo "Avg Latency: ${LATENCY}ms"
else
    echo "❌ Cannot get network status"
fi

echo -e "\n2. Connected Peers:"
PEER_INFO=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/ListConnectedPeers 2>/dev/null)
if [ $? -eq 0 ]; then
    PEER_COUNT=$(echo "$PEER_INFO" | jq '.connected_peers | length')
    echo "Connected peers: $PEER_COUNT"
    
    if [ "$PEER_COUNT" -gt 0 ]; then
        echo "Peer details:"
        echo "$PEER_INFO" | jq '.connected_peers[] | {
            addresses: .addresses,
            user_agent: .user_agent,
            features: .features
        }' | head -20
    fi
else
    echo "❌ Cannot get peer information"
fi

echo -e "\n3. Mempool Status:"
MEMPOOL_STATS=$(grpcurl -plaintext localhost:18142 tari.rpc.BaseNode/GetMempoolStats 2>/dev/null)
if [ $? -eq 0 ]; then
    UNCONFIRMED=$(echo "$MEMPOOL_STATS" | jq -r '.unconfirmed_txs // 0')
    WEIGHT=$(echo "$MEMPOOL_STATS" | jq -r '.unconfirmed_weight // 0')
    
    echo "Unconfirmed transactions: $UNCONFIRMED"
    echo "Total weight: $WEIGHT"
else
    echo "❌ Cannot get mempool stats"
fi

echo -e "\n4. Health Summary:"
if [ "$CONNECTIONS" -gt 3 ] && [ "$STATUS" = "Online" ]; then
    echo "✅ Network health: Good"
elif [ "$CONNECTIONS" -gt 0 ]; then
    echo "⚠️  Network health: Degraded"
else
    echo "❌ Network health: Poor"
fi</code></pre>
                </div>
            </div>
        </div>

        <div class="success">
            <strong>🎉 Congratulations!</strong> You've completed the comprehensive Tari exchange integration guide with pseudocode explanations and grpcurl testing examples. You now have all the tools and knowledge needed to successfully integrate Minotari (XTM) into your cryptocurrency exchange with a deep understanding of each operation.
        </div>

        <h3>📞 Support and Resources</h3>

        <ul>
            <li><strong>Documentation:</strong> <a href="https://rfc.tari.com" target="_blank">https://rfc.tari.com</a></li>
            <li><strong>GitHub Repository:</strong> <a href="https://github.com/tari-project/tari" target="_blank">https://github.com/tari-project/tari</a></li>
            <li><strong>Discord Community:</strong> <a href="https://discord.gg/tari" target="_blank">https://discord.gg/tari</a></li>
            <li><strong>Downloads:</strong> <a href="https://tari.com/downloads/" target="_blank">https://tari.com/downloads/</a></li>
            <li><strong>grpcurl Documentation:</strong> <a href="https://github.com/fullstorydev/grpcurl" target="_blank">https://github.com/fullstorydev/grpcurl</a></li>
        </ul>

        <div class="info">
            <strong>💡 Next Steps:</strong>
            <ul>
                <li>Test all pseudocode logic before implementing</li>
                <li>Use grpcurl examples to validate your gRPC setup</li>
                <li>Test the integration thoroughly on testnet</li>
                <li>Implement comprehensive monitoring and alerting</li>
                <li>Set up proper backup and disaster recovery procedures</li>
                <li>Conduct security audits before going live</li>
                <li>Join the Tari community for ongoing support</li>
            </ul>
        </div>

    </div>

    <script>
        function switchTab(evt, tabName) {
            // Get the parent tab container
            var tabContainer = evt.currentTarget.closest('.code-tabs');
            
            // Hide all tab contents in this container
            var tabContents = tabContainer.getElementsByClassName("tab-content");
            for (var i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove("active");
            }
            
            // Remove active class from all tab buttons in this container
            var tabButtons = tabContainer.getElementsByClassName("tab-button");
            for (var i = 0; i < tabButtons.length; i++) {
                tabButtons[i].classList.remove("active");
            }
            
            // Show the selected tab content and mark button as active
            document.getElementById(tabName).classList.add("active");
            evt.currentTarget.classList.add("active");
        }
    </script>
</body>
</html>